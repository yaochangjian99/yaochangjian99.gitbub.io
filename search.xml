<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java中的BigDecimal类你了解多少？</title>
    <url>/2021/03/04/BigDecimal%E7%B1%BB%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们都知道浮点型变量在进行计算的时候会出现丢失精度的问题。如下一段代码：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="number">0.05</span> + <span class="number">0.01</span>);</span><br><span class="line">System.out.println(<span class="number">1.0</span> - <span class="number">0.42</span>);</span><br><span class="line">System.out.println(<span class="number">4.015</span> * <span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="number">123.3</span> / <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0.060000000000000005</span></span><br><span class="line"><span class="number">0.5800000000000001</span></span><br><span class="line"><span class="number">401.49999999999994</span></span><br><span class="line"><span class="number">1.2329999999999999</span></span><br></pre></td></tr></table></figure>
<p>可以看到在Java中进行浮点数运算的时候，会出现丢失精度的问题。那么我们如果在进行商品价格计算的时候，就会出现问题。很有可能造成我们手中有0.06元，却无法购买一个0.05元和一个0.01元的商品。因为如上所示，他们两个的总和为0.060000000000000005。这无疑是一个很严重的问题，尤其是当电商网站的并发量上去的时候，出现的问题将是巨大的。可能会导致无法下单，或者对账出现问题。所以接下来我们就可以使用Java中的BigDecimal类来解决这类问题。</p>
<p>普及一下：</p>
<p>Java中float的精度为6-7位有效数字。double的精度为15-16位。</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">构造器                   描述                      </span><br><span class="line">BigDecimal(<span class="keyword">int</span>)       创建一个具有参数所指定整数值的对象。      </span><br><span class="line">BigDecimal(<span class="keyword">double</span>)    创建一个具有参数所指定双精度值的对象。     </span><br><span class="line">BigDecimal(<span class="keyword">long</span>)      创建一个具有参数所指定长整数值的对象。     </span><br><span class="line">BigDecimal(String)    创建一个具有参数所指定以字符串表示的数值的对象。</span><br></pre></td></tr></table></figure>
<p>函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法                    描述                         </span><br><span class="line">add(BigDecimal)       BigDecimal对象中的值相加，然后返回这个对象。</span><br><span class="line">subtract(BigDecimal)  BigDecimal对象中的值相减，然后返回这个对象。</span><br><span class="line">multiply(BigDecimal)  BigDecimal对象中的值相乘，然后返回这个对象。</span><br><span class="line">divide(BigDecimal)    BigDecimal对象中的值相除，然后返回这个对象。</span><br><span class="line">toString()            将BigDecimal对象的数值转换成字符串。    </span><br><span class="line">doubleValue()         将BigDecimal对象中的值以双精度数返回。   </span><br><span class="line">floatValue()          将BigDecimal对象中的值以单精度数返回。   </span><br><span class="line">longValue()           将BigDecimal对象中的值以长整数返回。    </span><br><span class="line">intValue()            将BigDecimal对象中的值以整数返回。     </span><br></pre></td></tr></table></figure>
<p>由于一般的数值类型，例如double不能准确的表示16位以上的数字。</p>
<h1 id="BigDecimal精度也丢失"><a href="#BigDecimal精度也丢失" class="headerlink" title="BigDecimal精度也丢失"></a>BigDecimal精度也丢失</h1><p>我们在使用BigDecimal时，使用它的BigDecimal(String)构造器创建对象才有意义。其他的如BigDecimal b = new BigDecimal(1)这种，还是会发生精度丢失的问题。如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="number">1.01</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="number">1.02</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.01&quot;</span>);</span><br><span class="line">BigDecimal d = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.02&quot;</span>);</span><br><span class="line">System.out.println(a.add(b));</span><br><span class="line">System.out.println(c.add(d));</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">2.0300000000000000266453525910037569701671600341796875</span></span><br><span class="line"><span class="number">2.03</span></span><br></pre></td></tr></table></figure>
<p>可见论丢失精度BigDecimal显的更为过分。但是使用Bigdecimal的BigDecimal(String)构造器的变量在进行运算的时候却没有出现这种问题。 究其原因计算机组成原理里面都有，它们的编码决定了这样的结果。long可以准确存储19位数字，而double只能准备存储16位数字。double由于有exp位，可以存16位以上的数字，但是需要以低位的不精确作为代价。如果需要高于19位数字的精确存储，则必须用BigInteger来保存，当然会牺牲一些性能。所以我们一般使用BigDecimal来解决商业运算上丢失精度的问题的时候，声明BigDecimal对象的时候一定要使用它构造参数为String的类型的构造器。</p>
<p>同时这个原则Effective Java和MySQL 必知必会中也都有提及。float和double只能用来做科学计算和工程计算。商业运算中我们要使用BigDecimal。</p>
<p>而且我们从源码的注释中官方也给出了说明，如下是BigDecimal类的double类型参数的构造器上的一部分注释说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* The results of <span class="keyword">this</span> constructor can be somewhat unpredictable.</span><br><span class="line">     * One might assume that writing &#123;<span class="meta">@code</span> <span class="keyword">new</span> BigDecimal(<span class="number">0.1</span>)&#125; in</span><br><span class="line">     * Java creates a &#123;<span class="meta">@code</span> BigDecimal&#125; which is exactly equal to</span><br><span class="line">     * <span class="number">0.1</span> (an unscaled value of <span class="number">1</span>, with a scale of <span class="number">1</span>), but it is</span><br><span class="line">     * actually equal to</span><br><span class="line">     * <span class="number">0.1000000000000000055511151231257827021181583404541015625</span>.</span><br><span class="line">     * This is because <span class="number">0.1</span> cannot be represented exactly as a</span><br><span class="line">     * &#123;<span class="meta">@code</span> <span class="keyword">double</span>&#125; (or, <span class="keyword">for</span> that matter, as a binary fraction of</span><br><span class="line">     * any finite length).  Thus, the value that is being passed</span><br><span class="line">     * &lt;i&gt;in&lt;/i&gt; to the constructor is not exactly equal to 0.1,</span><br><span class="line">     * appearances notwithstanding.</span><br><span class="line">       ……</span><br><span class="line">        * When a &#123;<span class="meta">@code</span> <span class="keyword">double</span>&#125; must be used as a source <span class="keyword">for</span> a</span><br><span class="line">     * &#123;<span class="meta">@code</span> BigDecimal&#125;, note that <span class="keyword">this</span> constructor provides an</span><br><span class="line">     * exact conversion; it does not give the same result as</span><br><span class="line">     * converting the &#123;<span class="meta">@code</span> <span class="keyword">double</span>&#125; to a &#123;<span class="meta">@code</span> String&#125; using the</span><br><span class="line">     * &#123;@link Double#toString(double)&#125; method and then using the</span><br><span class="line">     * &#123;@link #BigDecimal(String)&#125; constructor.  To get that result,</span><br><span class="line">     * use the &#123;@code static&#125; &#123;@link #valueOf(double)&#125; method.</span><br><span class="line">     * &lt;/ol&gt;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BigDecimal</span><span class="params">(<span class="keyword">double</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(val,MathContext.UNLIMITED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一段也说的很清楚它只能计算的无限接近这个数，但是无法精确到这个数。第二段则说，如果要想准确计算这个值，那么需要把double类型的参数转化为String类型的。并且使用BigDecimal(String)这个构造方法进行构造。 去获取结果。</p>
<h1 id="正确运用BigDecimal"><a href="#正确运用BigDecimal" class="headerlink" title="正确运用BigDecimal"></a>正确运用BigDecimal</h1><p>另外，BigDecimal所创建的是对象，我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象，由刚才我们所罗列的API也可看出。</p>
<p>在一般开发过程中，我们数据库中存储的数据都是float和double类型的。在进行拿来拿去运算的时候还需要不断的转化，这样十分的不方便。这里我写了一个工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Ji YongGuang.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 19:50 2017/12/14.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BigDecimalUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">add</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span> </span>&#123;<span class="comment">// v1 + v2</span></span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">        <span class="keyword">return</span> b1.add(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">sub</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">        <span class="keyword">return</span> b1.subtract(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">mul</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">        <span class="keyword">return</span> b1.multiply(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">div</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">        <span class="comment">// 2 = 保留小数点后两位   ROUND_HALF_UP = 四舍五入</span></span><br><span class="line">        <span class="keyword">return</span> b1.divide(b2, <span class="number">2</span>, BigDecimal.ROUND_HALF_UP);<span class="comment">// 应对除不尽的情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该工具类提供了double类型的基本的加减乘除运算。直接调用即可。</p>
<p>作者：HikariCP<br>链接：<a href="https://www.jianshu.com/p/c81edc59546c">https://www.jianshu.com/p/c81edc59546c</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
      <categories>
        <category>常用类</category>
      </categories>
      <tags>
        <tag>BigDecimal</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础--day01</title>
    <url>/2021/03/04/JAVA%E5%9F%BA%E7%A1%80--day01/</url>
    <content><![CDATA[<h3 id="和equals的区别"><a href="#和equals的区别" class="headerlink" title="==和equals的区别"></a>==和equals的区别</h3><hr>
<p>== 比较的是值</p>
<ul>
<li>比较基本的数据类型，比较的是数值</li>
<li>比较引用类型：比较引用指向的值（地址）</li>
</ul>
<a id="more"></a>

<p>equals</p>
<p><strong>默认比较也是地址，因为这个方法的最初定义在Object上，默认的实现就是比较地址</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;zs&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;zs&quot;</span>);</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">String s4 = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s1);<span class="comment">//false   s1堆地址  s3常量池地址</span></span><br><span class="line"></span><br><span class="line">String s5 = <span class="string">&quot;zszs&quot;</span>;</span><br><span class="line">String s6 = s3+s4;<span class="comment">//创建新对象</span></span><br><span class="line">System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String s7 = <span class="string">&quot;zs&quot;</span>;</span><br><span class="line"><span class="keyword">final</span> String s8 = <span class="string">&quot;zs&quot;</span>;<span class="comment">//final修饰 常量</span></span><br><span class="line"></span><br><span class="line">String s9 = s7+s8;</span><br><span class="line">System.out.println(s5 == s9);<span class="comment">//true s5常量 s9常量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String s10 = s3+s4;	<span class="comment">//final只影响s10，s3+s4仍然new，指向堆</span></span><br><span class="line">System.out.println(s5 == s10);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="final的作用"><a href="#final的作用" class="headerlink" title="final的作用"></a>final的作用</h3><p>final修饰类，表示类不可变，不可继承</p>
<p>比如，String，不可变性</p>
<p>final修饰方法，表示该方法不可重写</p>
<p>比如模板方法，可以固定我们的算法</p>
<p>final修饰变量，这个变量就是常量</p>
<p>注意：</p>
<p>修饰的是基本数据类型，这个值本身不能修改</p>
<p><strong>修饰的是引用类型，引用的指向不能修改</strong></p>
<p><strong>比如下面的代码是可以的</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Student student = <span class="keyword">new</span> Student(<span class="number">1</span>,<span class="string">&quot;Andy&quot;</span>);</span><br><span class="line">student.setAge(<span class="number">18</span>);<span class="comment">//注意，这个是可以的！</span></span><br></pre></td></tr></table></figure>
<h3 id="String，StringBuffer，StringBuilder区别"><a href="#String，StringBuffer，StringBuilder区别" class="headerlink" title="String，StringBuffer，StringBuilder区别"></a>String，StringBuffer，StringBuilder区别</h3><p>String 跟其他两个类的区别是</p>
<blockquote>
<p>String是final类型，每次声明的都是不可变的对象，<br>所以每次操作都会产生新的String对象，然后将指针指向新的String对象。</p>
</blockquote>
<p>StringBuffer，StringBuilder都是在原有对象上进行操作</p>
<blockquote>
<p>所以，如果需要经常改变字符串内容，则建议采用这两者。</p>
</blockquote>
<p>StringBuffer vs StringBuilder</p>
<blockquote>
<p>前者是线程安全的，后者是线程不安全的。<br>线程不安全性能更高，所以在开发中，优先采用StringBuilder.<br>StringBuilder &gt; StringBuffer &gt; String</p>
</blockquote>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210324153222042.png" alt="image-20210324153222042"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s = <span class="string">&quot;java&quot;</span>;</span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">这两者的内存分配方式是不一样的。</span><br><span class="line">第一种方式，JVM会将其分配到常量池，而第二种方式是分配到堆内存</span><br></pre></td></tr></table></figure>
<h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ul>
<li><p>JDK1.8之前：</p>
</li>
<li><ul>
<li><p>语法：</p>
</li>
<li><ul>
<li>抽象类：方法可以有抽象的，也可以有非抽象, 有构造器</li>
<li>接口：方法都是抽象，属性都是常量，默认有public static final修饰</li>
</ul>
</li>
<li><p>设计：</p>
</li>
<li><ul>
<li>抽象类：同一类事物的抽取，比如针对Dao层操作的封装，如，BaseDao，BaseServiceImpl</li>
<li>接口：通常更像是一种标准的制定，定制系统之间对接的标准</li>
<li>例子：</li>
<li>1，单体项目，分层开发，interface作为各层之间的纽带，在controller中注入IUserService，在Service注入IUserDao</li>
<li>2，分布式项目，面向服务的开发，抽取服务service，这个时候，就会产生服务的提供者和服务的消费者两个角色</li>
<li>这两个角色之间的纽带，依然是接口</li>
</ul>
</li>
</ul>
</li>
<li><p>JDK1.8之后：</p>
</li>
<li><ul>
<li>接口里面可以有实现的方法，注意要在方法的声明上加上default或者static</li>
</ul>
</li>
</ul>
<p>最后区分几个概念：</p>
<ul>
<li><p>多继承，多重继承，多实现</p>
</li>
<li><ul>
<li>多重继承：A-&gt;B-&gt;C（爷孙三代的关系）</li>
<li>多实现：Person implements IRunable,IEatable（符合多项国际化标准）</li>
<li>多继承：接口可以多继承，类只支持单继承</li>
</ul>
</li>
</ul>
<h3 id="Int和Integer的区别（重点）"><a href="#Int和Integer的区别（重点）" class="headerlink" title="Int和Integer的区别（重点）"></a>Int和Integer的区别（重点）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i1 = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">12</span>);</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">//false 指向堆中不同</span></span><br><span class="line"></span><br><span class="line">Integer i3 = <span class="number">126</span>;<span class="comment">//1.5之后自动装箱</span></span><br><span class="line">Integer i4 = <span class="number">126</span>;<span class="comment">//Integer.valueOf(126)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i5 = <span class="number">126</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">//true</span></span><br><span class="line">System.out.println(i3 == i5);<span class="comment">//true 自动拆箱 比较数值</span></span><br><span class="line"></span><br><span class="line">Integer i6 = <span class="number">128</span>;</span><br><span class="line">Integer i7 = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">int</span> i8 = <span class="number">128</span>;</span><br><span class="line">System.out.println(i6 == i7);</span><br><span class="line">System.out.println(i6 == i8);</span><br></pre></td></tr></table></figure>
<p>以上这些输出的答案是什么？true or false？ why？</p>
<p>你可以自己先思考，再看后面的答案分析。</p>
<p>答案揭晓</p>
<p>分情况来比较</p>
<ul>
<li>都定义为Integer的比较：</li>
</ul>
<blockquote>
<p>new：一旦new，就是开辟一块新内存，结果肯定是false<br>不new：<br>看范围<br>Integer做了缓存，-128至127，当你取值在这个范围的时候，会采用缓存的对象，所以会相等当不在这个范围，内部创建新的对象，此时不相等</p>
</blockquote>
<ul>
<li>Integer和int的比较：</li>
</ul>
<blockquote>
<p>实际比较的是数值，Integer会做拆箱的动作，来跟基本数据类型做比较<br>此时跟是否在缓存范围内或是否new都没关系</p>
</blockquote>
<p>源码分析：</p>
<blockquote>
<p>当我们写Integer i = 126,实际上做了自动装箱：Integer i = Integer.valueOf(126);<br>分析这段源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//IntegerCache是Integer的内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br></pre></td></tr></table></figure>
<h3 id="方法的重写和重载的区别"><a href="#方法的重写和重载的区别" class="headerlink" title="方法的重写和重载的区别"></a>方法的重写和重载的区别</h3><ul>
<li>重载：发生在一个类里面，方法名相同，参数列表不同（混淆点：跟返回类型没关系）</li>
</ul>
<blockquote>
<p>以下不构成重载<br>public double add(int a,int b)<br>public int add(int a,int b)​</p>
</blockquote>
<ul>
<li>重写：发生在父类子类之间的，方法名相同，参数列表相同</li>
</ul>
<h3 id="List和Set的区别-Collection和Collections区别"><a href="#List和Set的区别-Collection和Collections区别" class="headerlink" title="List和Set的区别,Collection和Collections区别"></a>List和Set的区别,Collection和Collections区别</h3><ul>
<li>List（有序，可重复）</li>
<li>Set（无序，不可重复）</li>
<li>Collection 顶层接口</li>
<li>Collections 工具类</li>
</ul>
<h3 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h3><h4 id="底层数据结构的差异"><a href="#底层数据结构的差异" class="headerlink" title="底层数据结构的差异"></a>底层数据结构的差异</h4><blockquote>
<p>ArrayList，数组，连续一块内存空间<br>LinkedList，双向链表，不是连续的内存空间</p>
</blockquote>
<h4 id="一个常规的结论"><a href="#一个常规的结论" class="headerlink" title="一个常规的结论"></a>一个常规的结论</h4><p>虽然不严谨，但也可以应付很多面试了</p>
<blockquote>
<p>ArrayList，查找快，因为是连续的内存空间，方便寻址，但删除，插入慢，因为需要发生数据迁移<br>LinkedList，查找慢，因为需要通过指针一个个寻找，但删除，插入块，因为只要改变前后节点的指针指向即可。</p>
</blockquote>
<ul>
<li>当都需要遍历查找的时候，查找速度差不多</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210324163925327.png" alt="image-20210324163925327"></p>
<ul>
<li>当插入都在末尾的时候，插入速度差不多</li>
</ul>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210324164403912.png" alt="image-20210324164403912"></p>
<h4 id="ArrayList细节分析"><a href="#ArrayList细节分析" class="headerlink" title="ArrayList细节分析"></a>ArrayList细节分析</h4><p>1，增加</p>
<ul>
<li><ul>
<li><p>添加到末尾，正常不需要做特别的处理，除非现有的数组空间不够了，需要扩容</p>
</li>
<li><ul>
<li><p>数组初始化容量多大？10，当你知道需要存储多少数据时，建议在创建的时候，直接设置初始化大小</p>
</li>
<li><p>怎么扩容？</p>
</li>
<li><ul>
<li>当发现容量不够之后，就进行扩容</li>
<li>按原先数组容量的1.5倍进行扩容，位运算，下面是关键的源码</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line"><span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li>再将原先数组的元素复制到新数组，Arrays</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">elementData = Arrays.copyOf(elementData, newCapacity)</span><br></pre></td></tr></table></figure>
<ul>
<li><ul>
<li>添加到其他位置，这个时候需要做整体的搬迁</li>
</ul>
</li>
<li><p>2，删除</p>
</li>
<li><ul>
<li>删除末尾，并不需要迁移</li>
<li>删除其他的位置，这个时候也需要搬迁</li>
</ul>
</li>
<li><p>3，修改</p>
</li>
<li><ul>
<li>修改之前，必须先定位</li>
<li>定位-查找-ArrayList（数组是一段连续的内存空间，定位会特别快）</li>
</ul>
</li>
<li><p>4，查找</p>
</li>
<li><ul>
<li>如上所述</li>
</ul>
</li>
</ul>
<h4 id="LinkedList细节分析"><a href="#LinkedList细节分析" class="headerlink" title="LinkedList细节分析"></a>LinkedList细节分析</h4><p>1，提供了的两个引用（first，last）</p>
<p>2，增加</p>
<p>添加到末尾，创建一个新的节点，将之前的last节点设置为新节点的pre，新节点设置为last</p>
<p>我们看下源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取到最后一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">//构建一个新节点，将当前的last作为这个新节点的pre</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//把last指向新节点</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="comment">//如果原先没有最后一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//将first指向新节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//否则，将原先的last的next指向新节点</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br><span class="line">Node节点的定义：内部类</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加到其他位置，这个时候，就需要调整前后节点的引用指向</p>
<p>3，如何去定义一个双向链表的节点，如上述的源码所示</p>
<p>4，修改</p>
<p>修改最后一个节点或者第一个节点，那么就很快（first，last）</p>
<p>修改其他位置，如果是按坐标来定位节点，则会按照二分查找法，源码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">    Node&lt;E&gt; x = first;</span><br><span class="line">    for (int i = 0; i &lt; index; i++)</span><br><span class="line">        x = x.next;</span><br><span class="line">    return x;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    Node&lt;E&gt; x = last;</span><br><span class="line">    for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">        x = x.prev;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>5，一个思考题，假如我们可以确定要存储1000个元素，那么采用ArrayList和LinkedList，</p>
<p>哪个更耗内存，为什么？</p>
<ul>
<li>​    ArrayList 初始化空间1000</li>
<li>​    LinkedList 有前后指针，更加浪费内存，比ArrayList多两千个指针</li>
</ul>
<p>6，LinkedList，要实现在A和B之间插入C，该如何实现，编写伪代码即可</p>
<p>​    假设我们定位到了A节点，那么A.next就是B节点，这个是前提。</p>
<p>​    你的答案是？可以思考过后，再看答案</p>
<p>​    C.pre = A;</p>
<p>​    C.next = A.next;</p>
<p>​    A.next.pre = C;</p>
<p>​    A.next = C;</p>
<h3 id="谈谈HashSet的存储原理"><a href="#谈谈HashSet的存储原理" class="headerlink" title="谈谈HashSet的存储原理"></a>谈谈HashSet的存储原理</h3><p>HashSet的存储原理或者工作原理，主要是从如何保证唯一性来说起。</p>
<p>这里面主要有3个问题，需要回答？</p>
<p>第一，为什么要采用Hash算法？有什么优势，解决了什么问题？</p>
<p>第二，所谓哈希表是一张什么表？</p>
<p>第三，HashSet如何保证保存对象的唯一性？会经历一个什么样的运算过程？</p>
<p>大家可以先思考，晚些再补充答案！</p>
<p>首先，我们要明确一点，HashSet底层采用的是HashMap来实现存储，其值作为HashMap的key</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>具体关于hashmap的细节再说</p>
<p><strong>第一，为什么要采用Hash算法？有什么优势，解决了什么问题？</strong></p>
<p>解决的问题是唯一性</p>
<p>存储数据，底层采用的是数组</p>
<p>当我们往数组放数据的时候，你如何 判断是否唯一？</p>
<p>可以采用遍历的方式，逐个比较，但是这种效率低，尤其是数据很多的情况下</p>
<p>所以，为了解决这个效率低的问题，我们采用新的方式</p>
<p>采用<strong>hash</strong>算法，通过计算存储对象的hashcode，然后再跟数组长度-1做位运算，得到我们要存储在数组的哪个下标下，如果此时计算的位置没有其他元素，直接存储，不用比较。</p>
<p>此处，我们只会用到hashCode</p>
<p>但是随着元素的不断添加，就可能出现“哈希冲突”，不同的对象计算出来的hash值是相同的，这个时候，我们就需要比较，才需要用到equals方法</p>
<p>如果equals相同，则不插入，不相等，则形成链表</p>
<p>第二，所谓哈希表是一张什么表？</p>
<p>本质是一个数组，而且数组的元素是链表</p>
<p>JDK1.7的版本实现</p>
<p>JDK1.8做了优化</p>
<p>随着元素不断添加，链表可能会越来越长，会优化红黑树</p>
<h3 id="谈谈LinkedHashMap和HashMap的区别（重点）"><a href="#谈谈LinkedHashMap和HashMap的区别（重点）" class="headerlink" title="谈谈LinkedHashMap和HashMap的区别（重点）"></a>谈谈LinkedHashMap和HashMap的区别（重点）</h3><p>主要关注几个点：</p>
<blockquote>
<p>1，初始化大小是16，如果事先知道数据量的大小，建议修改默认初始化大小。 减少扩容次数，提高性能 ，这是我一直会强调的点<br>2，最大的装载因子默认是0.75，当HashMap中元素个数达到容量的0.75时，就会扩容。 容量是原先的两倍<br>3，HashMap底层采用链表法来解决冲突。 但是存在一个问题，就是链表也可能会过长，影响性能<br>于是JDK1.8,对HashMap做了进一步的优化，引入了红黑树。当链表长度超过8，且数组容量大于64时，链表就会转换为红黑树，当红黑树的节点数量小于6时，会将红黑树转换为链表。因为在数据量较小的情况下，红黑树要维护自身平衡，比链表性能没有优势。</p>
</blockquote>
<p>其次，LinkedHashMap就是链表+散列表的结构，其底层采用了Linked双向链表来保存节点的访问顺序，所以保证了有序性。</p>
<h3 id="谈谈ConcurrentHashMap，HashMap，Hashtable的区别"><a href="#谈谈ConcurrentHashMap，HashMap，Hashtable的区别" class="headerlink" title="谈谈ConcurrentHashMap，HashMap，Hashtable的区别"></a>谈谈ConcurrentHashMap，HashMap，Hashtable的区别</h3><h4 id="1，首先，来看看其他几个相关的类"><a href="#1，首先，来看看其他几个相关的类" class="headerlink" title="1，首先，来看看其他几个相关的类"></a>1，首先，来看看其他几个相关的类</h4><blockquote>
<p>Hashtable是线程安全的，但效率低<br>HashMap是线程不安全的，但效率高<br>Collections.synchronizedMap()，工具类提供了同步包装器的方法，来返回具有线程安全的集合对象<br>性能依然有问题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">synchronizedMap</span><span class="params">(Map&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在这个类的内部方法实现上，也只是单纯加上了锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为解决这样的矛盾问题，所以JDK提供了并发包，来平衡这样的问题（java.util.concurrent）</p>
<h4 id="2，ConcurrentHashMap（重点）"><a href="#2，ConcurrentHashMap（重点）" class="headerlink" title="2，ConcurrentHashMap（重点）"></a>2，ConcurrentHashMap（重点）</h4><ul>
<li>兼顾了线程安全和效率的问题</li>
</ul>
<blockquote>
<p>分析：HashTable锁了整段数据（用户操作是不同的数据段，依然需要等待）<br>解决方案：把数据分段，执行分段锁（分离锁），核心把锁的范围变小，这样出现并发冲突的概率就变小<br>在保存的时候，计算所存储的数据是属于哪一段，只锁当前这一段</p>
</blockquote>
<ul>
<li><strong>注意：分段锁（分离锁）是JDK1.8之前的一种的方案，JDK1.8之后做了优化。</strong></li>
</ul>
<p><strong>JDK1.7跟JDK1.8在ConcurrentHashMap的实现上存在以下区别：</strong></p>
<p><strong>1，数据结构</strong></p>
<p>JDK1.7采用链表的方式，而JDK1.8则采用链表+红黑树的方式</p>
<p><strong>2，发生hash碰撞之后</strong></p>
<p>JDK1.7发生碰撞之后，会采用链表的方式来解决</p>
<p>JDK1.8发生碰撞之后，默认采用链表，但当链表的长度超过8，且数组容量超过64时，会转换为红黑树存储</p>
<p><strong>3，保证并发安全</strong></p>
<p>JDK1.7采用分段锁的方式，而JDK1.8采用CAS和synchronized的组合模式</p>
<p><strong>4，查询复杂度</strong></p>
<p>JDK1.7采用链表的方式，时间复杂度为O(n)，而JDK1.8在采用红黑树的方式时，时间复杂度为O(log(n))</p>
<p><strong>使用场景</strong>：</p>
<ul>
<li>优先选择HashMap，如果不是多个线程同时访问，优先选择HashMap,局部变量，不是全局变量</li>
<li>当时全局变量时，多个线程同时访问，选择ConcurrentHashMap</li>
</ul>
<p><strong>题外话：</strong></p>
<p><strong>不过红黑树其实是一种兜底方案，因为当链表数量达到8个的时候，其发生的概率是千万分之几，所以作者考虑到这种极端情况下，需要用红黑树的方式来优化</strong></p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>面试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程</title>
    <url>/2021/02/26/Java%20%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础--day02</title>
    <url>/2021/03/05/JAVA%E5%9F%BA%E7%A1%80--day02/</url>
    <content><![CDATA[<h3 id="serialVersionUID的作用是什么"><a href="#serialVersionUID的作用是什么" class="headerlink" title="serialVersionUID的作用是什么"></a>serialVersionUID的作用是什么</h3><p>当执行序列化时，我们写对象到磁盘中，会根据当前这个类的结构生成一个版本号ID</p>
<p>当反序列化时，程序会比较磁盘中的序列化版本号ID跟当前的类结构生成的版本号ID是否一致，如果一致则反序列化成功，否则，反序列化失败</p>
<p>加上版本号，有助于当我们的类结构发生了变化，依然可以之前已经序列化的对象反序列化成功</p>
<a id="more"></a>

<h3 id="线程部分"><a href="#线程部分" class="headerlink" title="线程部分"></a>线程部分</h3><h3 id="谈谈你对线程安全的理解？"><a href="#谈谈你对线程安全的理解？" class="headerlink" title="谈谈你对线程安全的理解？"></a>谈谈你对线程安全的理解？</h3><p><strong>如果这个是面试官直接问你的问题，你会怎么回答？</strong></p>
<blockquote>
<p>一个专业的描述是，当多个线程访问一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用这个对象的行为都可以获得正确的结果，我们就说这个对象是线程安全的</p>
</blockquote>
<p><strong>那么我们如何做到线程安全？</strong></p>
<blockquote>
<p>实现线程安全的方式有多种，其中在源码中常见的方式是，采用synchronized关键字给代码块或方法加锁，比如StringBuffer<br>查看StringBuffer的源码，你会看到是这样的：</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/80/v2-4423b8f2855af708b62c1c167b432ca0_720w.jpg" alt="img"></p>
<p>那么，我们开发中，如果需要拼接字符串，使用StringBuilder还是StringBuffer？</p>
<p>场景一：</p>
<p>如果是多个线程访问同一个资源，那么就需要上锁，才能保证数据的安全性。</p>
<p>这个时候如果使用的是非线程安全的对象，比如StringBuilder，那么就需要借助外力，给他加synchronized关键字。或者直接使用线程安全的对象StringBuffer</p>
<p>场景二：</p>
<p>如果每个线程访问的是各自的资源，那么就不需要考虑线程安全的问题，所以这个时候，我们可以放心使用非线程安全的对象，比如StringBuilder</p>
<p>比如在方法中，创建对象，来实现字符串的拼接。</p>
<p>看场景，如果我们是在方法中使用，那么建议在方法中创建StringBuilder，这时候相当是每个线程独立占有一个StringBuilder对象，不存在多线程共享一个资源的情况，所以我们可以安心使用，虽然StringBuilder本身不是线程安全的。</p>
<p><strong>什么时候需要考虑线程安全？</strong></p>
<p><strong>1，多个线程访问同一个资源</strong></p>
<p><strong>2，资源是有状态的，比如我们上述讲的字符串拼接，这个时候数据是会有变化的</strong></p>
<h3 id="谈谈Sleep和wait的区别"><a href="#谈谈Sleep和wait的区别" class="headerlink" title="谈谈Sleep和wait的区别"></a>谈谈Sleep和wait的区别</h3><h3 id="谈谈你对ThreadLocal的理解"><a href="#谈谈你对ThreadLocal的理解" class="headerlink" title="谈谈你对ThreadLocal的理解"></a>谈谈你对ThreadLocal的理解</h3><p>ThreadLocal解决了什么问题？内部源码是怎么样的？</p>
<p>作用：</p>
<p>为每个线程创建一个副本</p>
<p>实现在线程的上下文传递同一个对象，比如connection</p>
<p><strong>第一个问题：证明ThreadLocal为每个线程创建一个变量副本</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public class ThreadLocalTest &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;Long&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //开启多个线程来执行任务</span><br><span class="line">        Task task = new Task();</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">        Thread.sleep(10);</span><br><span class="line">        new Thread(task).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Task implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            Long result = threadLocal.get();</span><br><span class="line">            if(result == null)&#123;</span><br><span class="line">                threadLocal.set(System.currentTimeMillis());</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+&quot;-&gt;&quot;+threadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果是不同的</p>
<p><strong>问题二：为什么可以给每个线程保存一个不同的副本</strong></p>
<p>那我们来分析源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Long result = threadLocal.get();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//2，获取到当前线程对应的map</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//3.以threadLocal为key，获取到entry</span></span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                <span class="comment">//4.获取对应entry的value，就是我们存放到里面的变量的副本</span></span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们需要结合set方法的源码分析，才可以更好理解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">threadLocal.set(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取到当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//2.获取当前线程对应的map</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//3.往map存放一个键值对</span></span><br><span class="line">            <span class="comment">//this ThreadLocal</span></span><br><span class="line">            <span class="comment">//value 保存的副本</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们得到结论：</p>
<p>每个线程都会有对应的map，map来保存键值对。</p>
<p><strong>问题三：ThreadLocal这种特性，在实际开发中解决了什么问题？</strong></p>
<p>比如：hibernate管理session，mybatis管理sqlsession，其内部都是采用ThreadLocal来实现的。</p>
<p>前提知识：不管是什么框架，最本质的操作都是基于JDBC，当我们需要跟数据库打交道的时候，都需要有一个connection。</p>
<p>那么，当我们需要在业务层实现事务控制时，该如何达到这个效果？</p>
<p>我们构建下代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public class UserService &#123;</span><br><span class="line"></span><br><span class="line">    //省略接口的声明</span><br><span class="line">    private UserDao userDao = new UserDao();</span><br><span class="line">    private LogDao logDao = new LogDao();</span><br><span class="line"></span><br><span class="line">    //事务的边界放在业务层</span><br><span class="line">    //JDBC的封装，connection</span><br><span class="line">    public void add()&#123;</span><br><span class="line">        userDao.add();</span><br><span class="line">        logDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserDao &#123;</span><br><span class="line"></span><br><span class="line">    public void add()&#123;</span><br><span class="line">        System.out.println(&quot;UserDao add。。。&quot;);</span><br><span class="line">        //创建connection对象</span><br><span class="line">        //connection.commit();</span><br><span class="line">        //connection.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LogDao &#123;</span><br><span class="line"></span><br><span class="line">    public void add()&#123;</span><br><span class="line">        System.out.println(&quot;LogDao add。。。&quot;);</span><br><span class="line">        //创建connection对象</span><br><span class="line">        //connection.commit();</span><br><span class="line">        //connection.rollback();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果代码按上面的方式来管理connection，我们还可以保证service的事务控制吗？</p>
<p>这是不行的，假设第一个dao操作成功了，那么它就提交事务了，而第二个dao操作失败了，它回滚了事务，但不会影响到第一个dao的事务，因为上面这么写是两个独立的事务</p>
<p>那么怎么解决。</p>
<p>上面的根源就是两个dao操作的是不同的connection</p>
<p>所以，我们保证是同个connection即可</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//事务的边界放在业务层</span><br><span class="line">//JDBC的封装，connection</span><br><span class="line">public void add()&#123;</span><br><span class="line">    Connection connection = new Connection();</span><br><span class="line">    userDao.add(connection);</span><br><span class="line">    logDao.add(connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方式代码不够优雅</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public class ConnectionUtils &#123;</span><br><span class="line"></span><br><span class="line">    private static ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public static Connection getConnection()&#123;</span><br><span class="line">        Connection connection = threadLocal.get();</span><br><span class="line">        if(connection == null)&#123;</span><br><span class="line">            connection = new Connection();</span><br><span class="line">            threadLocal.set(connection);</span><br><span class="line">        &#125;</span><br><span class="line">        return connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UserDao &#123;</span><br><span class="line"></span><br><span class="line">    public void add()&#123;</span><br><span class="line">        System.out.println(&quot;UserDao add。。。&quot;);</span><br><span class="line">        //创建connection对象</span><br><span class="line">        //connection.commit();</span><br><span class="line">        //connection.rollback();</span><br><span class="line">        Connection connection = ConnectionUtils.getConnection();</span><br><span class="line">        System.out.println(&quot;UserDao-&gt;&quot;+connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此，我们可以保证两个dao操作的是同一个connection</p>
<h3 id="我们来谈谈类的加载机制"><a href="#我们来谈谈类的加载机制" class="headerlink" title="我们来谈谈类的加载机制"></a>我们来谈谈类的加载机制</h3><p><strong>面试场景：</strong></p>
<p>面试官第一问：</p>
<blockquote>
<p>请问，我现在编写一个类，类全名如下：java.lang.String,<br>我们知道JDK也给我们听过了一个java.lang.String，<br>那么，我们编写的这个String类能否替换到JDK默认提供，也就是说程序实际运行的时候，会加载我们的String还是JDK的String？为什么？</p>
</blockquote>
<p>如果，你无法确定？那么第二问：</p>
<blockquote>
<p>了解类的加载机制吗？知道JDK的类加载器吗？双亲委托机制说说看</p>
</blockquote>
<p>如果，你还不了解，那么我们聊聊今天的天气吧！</p>
<p><strong>1，首先，什么是类的加载机制？</strong></p>
<blockquote>
<p>JVM使用Java类的流程如下：<br>1，Java源文件—-编译—-&gt;class文件<br>2，类加载器ClassLoader会读取这个.class文件，并将其转化为java.lang.Class的实例。有了该实例，JVM就可以使用他来创建对象，调用方法等操作了。<br>那么ClassLoader是以一种什么机制来加载Class的？<br>这就是我们要谈的类的加载机制！</p>
</blockquote>
<p><strong>2，搞清楚这个问题，首先要知道，我们用到的Class文件都有哪些来源？</strong></p>
<blockquote>
<p>1，Java内部自带的核心类，位于$JAVA_HOME/jre/lib，其中最著名的莫过于rt.jar<br>2，Java的扩展类，位于$JAVA_HOME/jre/lib/ext目录下<br>3，我们自己开发的类或项目开发用到的第三方jar包，位于我们项目的目录下，比如WEB-INF/lib目录</p>
</blockquote>
<p><strong>3，那么，针对这些Class，JDK是怎么分工的？谁来加载这些Class？</strong></p>
<blockquote>
<p>针对不同的来源，Java分了不同的ClassLoader来加载<br>1，Java核心类，这些Java运行的基础类，由一个名为BootstrapClassLoader加载器负责加载。这个类加载器被称为“根加载器或引导加载器”<br>注意：BootstrapClassLoader不继承ClassLoader，是由JVM内部实现。法力无边，所以你通过java程序访问不到，得到的是null。<br>2，Java扩展类，是由ExtClassLoader负责加载，被称为“扩展类加载器”。<br>3，项目中编写的类，是由AppClassLoader来负责加载，被称为“系统类加载器”。</p>
</blockquote>
<p><strong>4， 那凭什么，我就知道这个类应该由老大BootStrapClassLoader来加载？</strong></p>
<p><strong>这里面就要基于双亲委托机制？</strong></p>
<blockquote>
<p>所谓双亲委托机制，就是加载一个类，会先获取到一个系统类加载器AppClassLoader的实例，然后往上层层请求，先由BootstarpClassLoader去加载，<br>如果BootStrapClassLoader发现没有，再下发给ExtClassLoader去加载，还是没有，才由AppClassLoader去加载。<br>如果还是没有，则报错</p>
</blockquote>
<p><strong>5，所以，上述问题的答案你清楚了吗？</strong></p>
<blockquote>
<p>JDK提供java.lang.String类，默认在rt.jar这个包里面，所以，默认会由BootstarpClassLoader加载，<br>所以，我们自己编写的java.lang.String，都没有机会被加载到</p>
</blockquote>
<p><strong>6，给两段程序看看，类加载器的关系</strong></p>
<p>案例1：创建一个自己的类，然后打印其类加载器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">		Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;com.huangguizhao.thread.client.Programmer&quot;</span>);</span><br><span class="line">		ClassLoader classLoader = clazz.getClassLoader();</span><br><span class="line">		System.out.println(classLoader.getClass().getSimpleName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>案例2：打印其双亲类加载器信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(classLoader.getParent() != <span class="keyword">null</span>)&#123;</span><br><span class="line">       classLoader = classLoader.getParent();</span><br><span class="line">       System.out.println(<span class="string">&quot;--&gt;&quot;</span>+classLoader.getClass().getSimpleName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="谈谈数据库设计的三大范式及反范式"><a href="#谈谈数据库设计的三大范式及反范式" class="headerlink" title="谈谈数据库设计的三大范式及反范式"></a>谈谈数据库设计的三大范式及反范式</h3><h3 id="左连接，右连接，内连接，如何编写SQL，他们的区别是什么？"><a href="#左连接，右连接，内连接，如何编写SQL，他们的区别是什么？" class="headerlink" title="左连接，右连接，内连接，如何编写SQL，他们的区别是什么？"></a>左连接，右连接，内连接，如何编写SQL，他们的区别是什么？</h3>]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>面试基础</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA基础-Mysql</title>
    <url>/2021/03/06/MYSQL/</url>
    <content><![CDATA[<p>mvcc</p>
<p>快照读可以一定程度解决幻读</p>
<p>修改数据，并且触发当前读的时候，可能发生幻读</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<a id="more"></a>

<h3 id="事务的四大特性-ACID"><a href="#事务的四大特性-ACID" class="headerlink" title="事务的四大特性(ACID)"></a>事务的四大特性(ACID)</h3><ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性（Consistency）：</strong> 执行事务后，数据库从一个正确的状态变化到另一个正确的状态；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<h3 id="并发事务带来哪些问题"><a href="#并发事务带来哪些问题" class="headerlink" title="并发事务带来哪些问题?"></a>并发事务带来哪些问题?</h3><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ul>
<p><strong>不可重复读和幻读区别：</strong></p>
<p>不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>
<h3 id="事务隔离级别有哪些-MySQL的默认隔离级别是"><a href="#事务隔离级别有哪些-MySQL的默认隔离级别是" class="headerlink" title="事务隔离级别有哪些?MySQL的默认隔离级别是?"></a>事务隔离级别有哪些?MySQL的默认隔离级别是?</h3><p><strong>SQL 标准定义了四个隔离级别：</strong></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ul>
<h3 id="MySQL-InnoDB-MVCC多版本并发控制"><a href="#MySQL-InnoDB-MVCC多版本并发控制" class="headerlink" title="MySQL-InnoDB-MVCC多版本并发控制"></a>MySQL-InnoDB-MVCC多版本并发控制</h3><p>如果有人从数据库中读数据的同时，有另外的人写入数据，有可能读数据的人会看到『半写』或者不一致的数据。有很多种方法来解决这个问题，叫做并发控制方法。最简单的方法，通过加锁，让所有的读者等待写者工作完成，但是这样效率会很差。MVCC 使用了一种不同的手段，每个连接到数据库的读者，在某个瞬间看到的是数据库的一个快照，写者写操作造成的变化在写操作完成之前（或者数据库事务提交之前）对于其他的读者来说是不可见的。当一个 MVCC 数据库需要更一个一条数据记录的时候，它不会直接用新数据覆盖旧数据，而是将旧数据标记为过时（obsolete）并在别处增加新版本的数据。这样就会有存储多个版本的数据，但是只有一个是最新的。这种方式允许读者读取在他读之前已经存在的数据，即使这些在读的过程中半路被别人修改、删除了，也对先前正在读的用户没有影响。这种多版本的方式避免了填充删除操作在内存和磁盘存储结构造成的空洞的开销，但是需要系统周期性整理（sweep through）以真实删除老的、过时的数据。对于面向文档的数据库（Document-oriented database，也即半结构化数据库）来说，这种方式允许系统将整个文档写到磁盘的一块连续区域上，当需要更新的时候，直接重写一个版本，而不是对文档的某些比特位、分片切除，或者维护一个链式的、非连续的数据库结构。MVCC 提供了时点（point in time）一致性视图。MVCC 并发控制下的读事务一般使用时间戳或者事务 ID去标记当前读的数据库的状态（版本），读取这个版本的数据。读、写事务相互隔离，不需要加锁。读写并存的时候，写操作会根据目前数据库的状态，创建一个新版本，并发的读则依旧访问旧版本的数据。一句话讲，<strong>MVCC就是用 同一份数据临时保留多版本的方式 的方式，实现并发控制。</strong></p>
<ul>
<li>MVCC是被Mysql中 <code>事务型存储引擎InnoDB</code> 所支持的;</li>
<li><strong>应对高并发事务, MVCC比<code>单纯的加锁</code>更高效</strong>;</li>
<li>MVCC只在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作;</li>
<li>MVCC可以使用 <code>乐观(optimistic)锁</code> 和 <code>悲观(pessimistic)锁</code>来实现;</li>
</ul>
<h3 id="MVCC常用实现方法"><a href="#MVCC常用实现方法" class="headerlink" title="MVCC常用实现方法"></a>MVCC常用实现方法</h3><ul>
<li>写新数据时，把旧数据转移到一个单独的地方，如回滚段中，其他人读数据时，从回滚段中把旧的数据读出来，如Oracle数据库和MySQL中的innodb引擎。</li>
<li>写新数据时，旧数据不删除，而是把新数据插入。PostgreSQL就是使用的这种实现方法。</li>
</ul>
<p><strong>read view, 快照snapshot</strong></p>
<p>事务快照是用来存储数据库的事务运行情况。一个事务快照的创建过程可以概括为：查看当前所有的未提交并活跃的事务，存储在数组中选取未提交并活跃的事务中最小的XID，记录在快照的xmin中，选取所有已提交事务中最大的XID，加1后记录在xmax中</p>
<p><strong>行结构</strong></p>
<p>每一行额外包含三个隐藏字段：</p>
<ul>
<li>DB_TRX_ID：事务ID。行的创建时间和删除时间记录的就是此值。</li>
<li>DB_ROLL_PTR：指向当前记录项的undo信息。</li>
<li>DB_ROW_ID:：随着新行插入单调递增的一个字段。当由innodb自动产生聚集索引时，聚集索引包括这个DB_ROW_ID的值，不然的话聚集索引中不包括这个值。</li>
<li>在insert操作时，创建时间 = DB_ROW_ID，这时，“删除时间 ”是未定义的。</li>
<li>在update操作时，复制新增行的“创建时间”=DB_ROW_ID，删除时间未定义，旧数据行“创建时间”不变，删除时间=该事务的DB_ROW_ID。</li>
<li>在delete操作时，相应数据行的“创建时间”不变，删除时间 = 该事务的DB_ROW_ID。</li>
<li>select操作对两者都不修改，只读相应的数据。</li>
</ul>
<p><strong>关于low_limit_id，up_limit_id的理解：</strong><br>up_limit_id：当前已经提交的事务号 + 1，事务号 &lt; up_limit_id ，对于当前Read View都是可见的。理解起来就是创建Read View视图的时候，之前已经提交的事务对于该事务肯定是可见的。<br>low_limit_id：当前最大的事务号 + 1，事务号 &gt;= low_limit_id，对于当前Read View都是不可见的。理解起来就是在创建Read View视图之后创建的事务对于该事务肯定是不可见的。</p>
<h2 id="锁机制与InnoDB锁算法"><a href="#锁机制与InnoDB锁算法" class="headerlink" title="锁机制与InnoDB锁算法"></a>锁机制与InnoDB锁算法</h2><h3 id="锁分类（按照锁的粒度分类）"><a href="#锁分类（按照锁的粒度分类）" class="headerlink" title="锁分类（按照锁的粒度分类）"></a>锁分类（按照锁的粒度分类）</h3><p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p>
<ul>
<li>MyISAM采用表级锁(table-level locking)。</li>
<li>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</li>
</ul>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li><strong>表级锁：</strong> MySQL中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<p><strong>InnoDB存储引擎的锁的算法有三种：</strong></p>
<ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<h3 id="锁分类（按照是否可写分类）"><a href="#锁分类（按照是否可写分类）" class="headerlink" title="锁分类（按照是否可写分类）"></a>锁分类（按照是否可写分类）</h3><p>表级锁和行级锁可以进一步划分为共享锁（s）和排他锁（X）。</p>
<p><strong>共享锁（s）</strong></p>
<p>​    共享锁（Share Locks，简记为S）又被称为读锁，其他用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。</p>
<p>​    共享锁(S锁)又称为读锁，若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p>
<p><strong>排他锁（X）：</strong></p>
<p>​    排它锁（(Exclusive lock,简记为X锁)）又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。</p>
<p><strong>两者之间的区别：</strong></p>
<ul>
<li><p>共享锁（S锁）：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不 能加排他锁。获取共享锁的事务只能读数据，不能修改数据。</p>
</li>
<li><p>排他锁（X锁）：如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获取排他锁的事务既能读数据，又能修改数据。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>final关键字</title>
    <url>/2021/02/25/final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>当final修饰一个类时，表明其为最终类，它不能被继承，并且类中所有的属性和方法都默认是final类型，如String，Integer等包装类均为final类。</p>
<a id="more"></a>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>被final修饰的方法不可被重写。它可以防止任何继承类修改方法的意义和实现，而且，使用final修饰方法的执行效率一般高于普通方法</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>使用final修饰的变量称为常量（大写字母表示），只能被赋值一次，且赋值之后无法改变，这里的变量又可以分为基本类型变量和引用类型变量，final修饰基本类型变量时，变量的值不可改变；修饰引用变量时，变量指向的对象地址不可改变。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>final修饰的参数有一个只读的属性，即可以读取该参数，但是无法更改参数的值，同修饰变量一样，当参数为基本类型时，该参数的值不可改变；当参数为引用类型时，参数的引用地址不可改变。</p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>final</tag>
        <tag>关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2020/06/07/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-结构型模式</tag>
        <tag>代理模式代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算</title>
    <url>/2020/06/19/%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h2 id="位运算基础"><a href="#位运算基础" class="headerlink" title="位运算基础"></a>位运算基础</h2><ul>
<li><p>&amp;（与）、|（或）、^（异或）、~ （非 / 取反）</p>
</li>
<li><p><code>&gt;&gt;</code> 和 <code>&lt;&lt;</code>运算符将二进制为进行右移或者左移操作</p>
</li>
<li><p><code>&gt;&gt;&gt;</code>运算符将用0填充高位；<code>&gt;&gt;</code>运算符用符号位填充高位，没有<code>&lt;&lt;&lt;</code>运算符</p>
<a id="more"></a>

</li>
</ul>
<h2 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a><strong>位操作符</strong></h2><ul>
<li>&amp; 与运算 两个位都是 1 时，结果才为 1，否则为 0，如<pre><code> 1 0 0 1 1 
</code></pre>
&amp;  1 1 0 0 1<br><code>------------------------------</code> <pre><code> 1 0 0 0 1 
</code></pre>
</li>
</ul>
<ul>
<li>| 或运算 两个位都是 0 时，结果才为 0，否则为 1，如<pre><code> 1 0 0 1 1 
</code></pre>
|   1 1 0 0 1<br><code>------------------------------</code> <pre><code> 1 1 0 1 1 
</code></pre>
</li>
</ul>
<ul>
<li>^ 异或运算，两个位相同则为 0，不同则为 1，如<pre><code>1 0 0 1 1 
</code></pre>
^  1 1 0 0 1<br><code>-----------------------------</code> <pre><code>0 1 0 1 0 
</code></pre>
</li>
</ul>
<ul>
<li>~ 取反运算，0 则变为 1，1 则变为 0，如<br>~   1 0 0 1 1<br><code>-----------------------------</code> <pre><code> 0 1 1 0 0 
</code></pre>
</li>
</ul>
<ul>
<li>&lt;&lt; 左移运算，向左进行移位操作，高位丢弃，低位补 0，如</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int a = 8;</span><br><span class="line">a &lt;&lt; 3;</span><br><span class="line">移位前：0000 0000 0000 0000 0000 0000 0000 1000</span><br><span class="line">移位后：0000 0000 0000 0000 0000 0000 0100 0000</span><br></pre></td></tr></table></figure>
<p>&gt;&gt; 右移运算，向右进行移位操作，对无符号数，高位补 0，对于有符号数，高位补符号位，如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">unsigned int a = 8;</span><br><span class="line">a &gt;&gt; 3;</span><br><span class="line">移位前：0000 0000 0000 0000 0000 0000 0000 1000</span><br><span class="line">移位后：0000 0000 0000 0000 0000 0000 0000 0001</span><br><span class="line"></span><br><span class="line">int a = -8;</span><br><span class="line">a &gt;&gt; 3;</span><br><span class="line">移位前：1111 1111 1111 1111 1111 1111 1111 1000</span><br><span class="line">移位前：1111 1111 1111 1111 1111 1111 1111 1111</span><br></pre></td></tr></table></figure>
<h2 id="常见位运算问题"><a href="#常见位运算问题" class="headerlink" title="常见位运算问题"></a><strong>常见位运算问题</strong></h2><h3 id="1-位操作实现乘除法"><a href="#1-位操作实现乘除法" class="headerlink" title="1. 位操作实现乘除法"></a>1. 位操作实现乘除法</h3><ul>
<li>数 a 向右移一位，相当于将 a 除以 2；数 a 向左移一位，相当于将 a 乘以 2</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int a = 2;</span><br><span class="line">a &gt;&gt; 1; ---&gt; 1</span><br><span class="line">a &lt;&lt; 1; ---&gt; 4</span><br></pre></td></tr></table></figure>
<h3 id="2-位操作交货两数"><a href="#2-位操作交货两数" class="headerlink" title="2. 位操作交货两数"></a>2. 位操作交货两数</h3><ul>
<li>位操作交换两数可以不需要第三个临时变量，虽然普通操作也可以做到，但是没有其效率高</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">//普通操作</span><br><span class="line">void swap(int &amp;a, int &amp;b) &#123;</span><br><span class="line">  c = a + b;</span><br><span class="line">  b = c - b;</span><br><span class="line">  a = c - a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//位与操作</span><br><span class="line">void swap(int &amp;a, int &amp;b) &#123;</span><br><span class="line">  a ^= b;</span><br><span class="line">  b ^= a;</span><br><span class="line">  a ^= b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>位与操作解释：第一步：a ^= b —&gt; a = (a^b); </p>
<p>第二步：b ^= a —&gt; b = b^(a^b) —&gt; b = (b^b)^a = a</p>
<p>第三步：a ^= b —&gt; a = (a^b)^a = (a^a)^b = b</p>
<h3 id="3-位操作判断奇偶数"><a href="#3-位操作判断奇偶数" class="headerlink" title="3. 位操作判断奇偶数"></a>3. 位操作判断奇偶数</h3><ul>
<li>只要根据数的最后一位是 0 还是 1 来决定即可，为 0 就是偶数，为 1 就是奇数。</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">if(0 == (a &amp; 1)) &#123;</span><br><span class="line"> //偶数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-位操作交换符号"><a href="#4-位操作交换符号" class="headerlink" title="4. 位操作交换符号"></a>4. 位操作交换符号</h3><ul>
<li>交换符号将正数变成负数，负数变成正数</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int reversal(int a) &#123;</span><br><span class="line">  return ~a + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整数取反加1，正好变成其对应的负数(补码表示)；负数取反加一，则变为其原码，即正数</p>
<h3 id="5-位操作求绝对值"><a href="#5-位操作求绝对值" class="headerlink" title="5. 位操作求绝对值"></a>5. 位操作求绝对值</h3><ul>
<li>整数的绝对值是其本身，负数的绝对值正好可以对其进行取反加一求得，即我们首先判断其符号位（整数右移 31 位得到 0，负数右移 31 位得到 -1,即 0xffffffff），然后根据符号进行相应的操作</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int abs(int a) &#123;</span><br><span class="line">  int i = a &gt;&gt; 31;</span><br><span class="line">  return i == 0 ? a : (~a + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的操作可以进行优化，可以将 i == 0 的条件判断语句去掉。我们都知道符号位 i 只有两种情况，即 i = 0 为正，i = -1 为负。对于任何数与 0 异或都会保持不变，与 -1 即 0xffffffff 进行异或就相当于对此数进行取反,因此可以将上面三目元算符转换为((a^i)-i)，即整数时 a 与 0 异或得到本身，再减去 0，负数时与 0xffffffff 异或将 a 进行取反，然后在加上 1，即减去 i(i =-1)</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">int abs2(int a) &#123;</span><br><span class="line">  int i = a &gt;&gt; 31;</span><br><span class="line">  return ((a^i) - i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-位操作进行高低位交换"><a href="#6-位操作进行高低位交换" class="headerlink" title="6. 位操作进行高低位交换"></a>6. 位操作进行高低位交换</h3><ul>
<li>给定一个 16 位的无符号整数，将其高 8 位与低 8 位进行交换，求出交换后的值，如：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">34520的二进制表示：</span><br><span class="line">10000110 11011000</span><br><span class="line"></span><br><span class="line">将其高8位与低8位进行交换，得到一个新的二进制数：</span><br><span class="line">11011000 10000110</span><br><span class="line">其十进制为55430</span><br></pre></td></tr></table></figure>
<p>从上面移位操作我们可以知道，只要将无符号数 a&gt;&gt;8 即可得到其高 8 位移到低 8 位，高位补 0；将 a&lt;&lt;8 即可将 低 8 位移到高 8 位，低 8 位补 0，然后将 a&gt;&gt;8 和 a&lt;&lt;8 进行或操作既可求得交换后的结果。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">unsigned short a = 34520;</span><br><span class="line">a = (a &gt;&gt; 8) | (a &lt;&lt; 8);</span><br></pre></td></tr></table></figure>
<h3 id="7-位操作进行二进制逆序"><a href="#7-位操作进行二进制逆序" class="headerlink" title="7. 位操作进行二进制逆序"></a>7. 位操作进行二进制逆序</h3><p>将无符号数的二进制表示进行逆序，求取逆序后的结果，如</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">数34520的二进制表示：</span><br><span class="line">10000110 11011000</span><br><span class="line"></span><br><span class="line">逆序后则为：</span><br><span class="line">00011011 01100001</span><br><span class="line">它的十进制为7009</span><br></pre></td></tr></table></figure>
<p>在字符串逆序过程中，可以从字符串的首尾开始，依次交换两端的数据。在二进制中使用位的高低位交换会更方便进行处理，这里我们分组进行多步处理。</p>
<ul>
<li>第一步:以每 2 位为一组，组内进行高低位交换</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">交换前： 10 00 01 10 11 01 10 00</span><br><span class="line">交换后： 01 00 10 01 11 10 01 00</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步：在上面的基础上，以每 4 位为 1 组，组内高低位进行交换</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">交换前： 0100 1001 1110 0100</span><br><span class="line">交换后： 0001 0110 1011 0001</span><br></pre></td></tr></table></figure>
<ul>
<li>第三步：以每 8 位为一组，组内高低位进行交换</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">交换前： 00010110 10110001</span><br><span class="line">交换后： 01100001 00011011</span><br></pre></td></tr></table></figure>
<ul>
<li>第四步：以每16位为一组，组内高低位进行交换</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">交换前： 0110000100011011</span><br><span class="line">交换后： 0001101101100001</span><br></pre></td></tr></table></figure>
<p>对于上面的第一步，依次以 2 位作为一组，再进行组内高低位交换，这样处理起来比较繁琐，下面介绍另外一种方法进行处理。先分别取原数 10000110 11011000 的奇数位和偶数位，将空余位用 0 填充：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">原数：  10000110 11011000</span><br><span class="line">奇数位： 10000010 10001000</span><br><span class="line">偶数位： 00000100 01010000</span><br></pre></td></tr></table></figure>
<p>再将奇数位右移一位，偶数位左移一位，此时将两个数据相或即可以达到奇偶位上数据交换的效果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">原数：  10000110 11011000</span><br><span class="line">奇数位右移一位： 0 10000010 1000100</span><br><span class="line">偶数位左移一位：0000100 01010000 0</span><br><span class="line">两数相或得到： 01001001 11100100</span><br></pre></td></tr></table></figure>
<p>上面的方法用位操作可以表示为：</p>
<ul>
<li>取a的奇数位并用 0 进行填充可以表示为：a &amp; 0xAAAA</li>
<li>取a的偶数为并用 0 进行填充可以表示为：a &amp; 0x5555 因此，上面的第一步可以表示为：<br>a = ((a &amp; 0xAAAA) &gt;&gt; 1) | ((a &amp; 0x5555) &lt;&lt; 1)<br>同理，可以得到其第二、三和四步为：<br>a = ((a &amp; 0xCCCC) &gt;&gt; 2) | ((a &amp; 0x3333) &lt;&lt; 2)<br>a = ((a &amp; 0xF0F0) &gt;&gt; 4) | ((a &amp; 0x0F0F) &lt;&lt; 4)<br>a = ((a &amp; 0xFF00) &gt;&gt; 8) | ((a &amp; 0x00FF) &lt;&lt; 8)<br>因此整个操作为：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">unsigned short a = 34520;</span><br><span class="line"></span><br><span class="line">a = ((a &amp; 0xAAAA) &gt;&gt; 1) | ((a &amp; 0x5555) &lt;&lt; 1);</span><br><span class="line">a = ((a &amp; 0xCCCC) &gt;&gt; 2) | ((a &amp; 0x3333) &lt;&lt; 2);</span><br><span class="line">a = ((a &amp; 0xF0F0) &gt;&gt; 4) | ((a &amp; 0x0F0F) &lt;&lt; 4);</span><br><span class="line">a = ((a &amp; 0xFF00) &gt;&gt; 8) | ((a &amp; 0x00FF) &lt;&lt; 8);</span><br></pre></td></tr></table></figure>
<h3 id="8-位操作统计二进制中-1-的个数"><a href="#8-位操作统计二进制中-1-的个数" class="headerlink" title="8. 位操作统计二进制中 1 的个数"></a>8. 位操作统计二进制中 1 的个数</h3><p>统计二进制1的个数可以分别获取每个二进制位数，然后再统计其1的个数，此方法效率比较低。这里介绍另外一种高效的方法，同样以 34520 为例，我们计算其 a &amp;= (a-1)的结果：</p>
<ul>
<li>第一次：计算前：1000 0110 1101 1000 计算后：1000 0110 1101 0000</li>
<li>第二次：计算前：1000 0110 1101 0000 计算后：1000 0110 1100 0000</li>
<li>第二次：计算前：1000 0110 1100 0000 计算后：1000 0110 1000 0000 我们发现，没计算一次二进制中就少了一个 1，则我们可以通过下面方法去统计：</li>
</ul>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">count = 0  </span><br><span class="line">while(a)&#123;  </span><br><span class="line">  a = a &amp; (a - 1);  </span><br><span class="line">  count++;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>作者：力扣（LeetCode）<br>链接：<a href="https://www.zhihu.com/question/38206659/answer/736472332">https://www.zhihu.com/question/38206659/answer/736472332</a><br>来源：知乎</p>
]]></content>
      <categories>
        <category>基础复习</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>nockout</title>
    <url>/2021/03/04/%E5%89%8D%E7%AB%AF/</url>
    <content><![CDATA[<p>连接：</p>
<p>方式一：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#/pages/material_manager/materialedit?id=&quot;</span> <span class="attr">data-toggle</span>=<span class="string">&quot;tooltip&quot;</span> <span class="attr">data-placement</span>=<span class="string">&quot;right&quot;</span> <span class="attr">data-original-title</span>=<span class="string">&quot;新增物料&quot;</span> <span class="attr">data-bind</span>=<span class="string">&quot;i18n:&#123;&#x27;title&#x27;:&#x27;matManage-addmaterial&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-plus&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span> <span class="attr">data-bind</span>=<span class="string">&quot;i18n:&#x27;matManage-addmaterial&#x27;&quot;</span>&gt;</span>新增物料<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>连接跳转</tag>
      </tags>
  </entry>
  <entry>
    <title>JDK中单例模式</title>
    <url>/2020/06/04/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="java-lang-Runtime-getRuntime"><a href="#java-lang-Runtime-getRuntime" class="headerlink" title="java.lang.Runtime#getRuntime()"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime--"><code>java.lang.Runtime#getRuntime()</code></a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Don&#x27;t let anyone else instantiate this class */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="java-awt-Desktop-getDesktop"><a href="#java-awt-Desktop-getDesktop" class="headerlink" title="java.awt.Desktop#getDesktop()"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--"><code>java.awt.Desktop#getDesktop()</code></a></h2><h2 id="java-lang-System-getSecurityManager"><a href="#java-lang-System-getSecurityManager" class="headerlink" title="java.lang.System#getSecurityManager()"></a><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--"><code>java.lang.System#getSecurityManager()</code></a></h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">System</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Don&#x27;t let anyone instantiate this class */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">System</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>原码</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2020/06/03/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="单例设计模式介绍"><a href="#单例设计模式介绍" class="headerlink" title="单例设计模式介绍"></a>单例设计模式介绍</h2><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对<strong>某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法(静态方法)。</strong></p>
<a id="more"></a>


<h3 id="单例模式注意事项和细节说明"><a href="#单例模式注意事项和细节说明" class="headerlink" title="单例模式注意事项和细节说明"></a>单例模式注意事项和细节说明</h3><ol>
<li>单例模式保证了 系统内存中该类<strong>只存在一个对象，节省了系统资</strong>源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li>
<li><strong>当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new</strong></li>
<li>单例模式使用的场景：需要<strong>频繁的进行创建和销毁的对象</strong>、<strong>创建对象时耗时过多或耗费资源过多</strong>(即：重量级对象)，但又经<strong>常用到的对象、工具类对象、频繁访问数据库或文件的对象</strong>(比如数据源、session工厂等)</li>
</ol>
<h2 id="单例模式有八种方式："><a href="#单例模式有八种方式：" class="headerlink" title="单例模式有八种方式："></a>单例模式有八种方式：</h2><h3 id="饿汉式（静态常量）"><a href="#饿汉式（静态常量）" class="headerlink" title="饿汉式（静态常量）"></a>饿汉式（静态常量）</h3><p><strong>应用实例</strong><br>步骤如下：<br>    1) <strong>构造器私有化</strong> (防止 new )<br>    2) <strong>类的内部创建对象</strong><br>    3) <strong>向外暴露一个静态的公共方法</strong>。getInstance<br>    4) 代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance1==instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点说明：</strong></p>
<ol>
<li>优点：这种<strong>写法比较简单</strong>，就是在类装载的时候就完成实例化。<strong>避免了线程同步问题。</strong></li>
<li>缺点：在<strong>类装载的时候就完成实例化</strong>，没有达到Lazy Loading的效果。<strong>如果从始至终从未使用过这个实例，则会造成内存的浪费</strong></li>
<li>这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法， 但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果</li>
<li><strong>结论：这种单例模式可用，可能造成内存浪费</strong></li>
</ol>
<h3 id="饿汉式（静态代码块）"><a href="#饿汉式（静态代码块）" class="headerlink" title="饿汉式（静态代码块）"></a>饿汉式（静态代码块）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton02 instance1 = Singleton02.getInstance();</span><br><span class="line">        Singleton02 instance2 = Singleton02.getInstance();</span><br><span class="line">        System.out.println(instance1==instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton02</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton02</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton02 instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">       instance = <span class="keyword">new</span> Singleton02();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点说明：</strong></p>
<ol>
<li>这种方式和上面的方式其实类似，只不过将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。<strong>优缺点和上面是一样的。</strong></li>
<li>结论：这种单例模式可用，但是可能造成内存浪费</li>
</ol>
<h3 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance1==instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点说明</strong>：</p>
<ol>
<li>起到了Lazy Loading的效果，但是只能在单线程下使用。</li>
<li>如果在多线程下，<strong>一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实</strong>例。所以<br>在多线程环境下不可使用这种方式</li>
<li>结论：<strong>在实际开发中，不要使用这种方式</strong></li>
</ol>
<h3 id="懒汉式-线程安全，同步方法"><a href="#懒汉式-线程安全，同步方法" class="headerlink" title="懒汉式(线程安全，同步方法)"></a>懒汉式(线程安全，同步方法)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance1==instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点说明</strong>：</p>
<ol>
<li>解决了线程不安全问题</li>
<li><strong>效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步</strong>。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。<strong>方法进行同步效率太低</strong></li>
<li>结论：在实际开发中，不推荐使用这种方式</li>
</ol>
<p><strong>原文链接synchronized</strong>：<a href="https://blog.csdn.net/javazejian/article/details/72828483">深入理解Java并发之synchronized实现原理</a></p>
<ol>
<li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</li>
<li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</li>
<li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
</ol>
<p>1、同步方法（静态方法，实例方法）:<br>使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。。。。。</p>
<h3 id="懒汉式-线程不安全，同步代码块"><a href="#懒汉式-线程不安全，同步代码块" class="headerlink" title="懒汉式(线程不安全，同步代码块)"></a>懒汉式(线程不安全，同步代码块)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">type05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance1==instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点说明</strong>：</p>
<ol>
<li>这种方式，本意是想对第四种实现方式的改进，因为前面同步方法效率太低，改为同步产生实例化的的代码块</li>
<li>但是这种<strong>同步并不能起到线程同步的作用</strong>。跟<strong>第3种实现方式遇到的情形一致</strong>，假如一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例</li>
<li>结论：在实际开发中，不能使用这种方式</li>
</ol>
<h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">type06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance1==instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>简述</strong>：volatile是轻量级的synchronized,它在多处理器开发中保证了共享变量的“可见性”，可见性的意思是一个线程修改一个共享变量时，另一个线程可以读到这个修改的值，如果volatile使用恰当的话，它比synchronized的使用成本更低，因为它不会引起线程的上下文切换和调度。<br>原文链接：<a href="https://blog.csdn.net/summerZBH123/article/details/80547516">Volatile关键字介绍</a></p>
<p><strong>优缺点说明</strong>：</p>
<ol>
<li>Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了<strong>两次if (singleton == null)检查，这样就可以保证线程安全了</strong></li>
<li>这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象，也避免的反复进行方法同步.</li>
<li>线程安全；<strong>延迟加载；效率较高</strong></li>
<li>结论：在实际开发中，<strong>推荐使用这种单例设计模式</strong><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">type07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.getInstance();</span><br><span class="line">        Singleton instance2 = Singleton.getInstance();</span><br><span class="line">        System.out.println(instance1==instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>优缺点说明</strong>：</p>
<ol>
<li>这种方式<strong>采用了类装载的机制来保证初始化实例时只有一个线程</strong>。</li>
<li>静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，<strong>调用getInstance方法，才会装载SingletonInstance类，从而完Singleton的实例化</strong>。</li>
<li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。**( 使用静态内部类能保证线程安全的原因由于内部静态类只会被加载一次，故该实现方式是线程安全的。类加载的初始化阶段是单线程的）**</li>
<li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高</li>
<li>结论：推荐使用</li>
</ol>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">type08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton instance1 = Singleton.INSTAnNCE;</span><br><span class="line">        Singleton instance2 = Singleton.INSTAnNCE;</span><br><span class="line">        System.out.println(instance1==instance2);</span><br><span class="line">        instance1.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span>  <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>优缺点说明</strong>：</p>
<ol>
<li>这借助JDK1.5中添加的枚举来实现单例模式。<strong>不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象</strong>。</li>
<li>这种方式是Effective Java作者Josh Bloch 提倡的方式</li>
<li>结论：<strong>推荐使用</strong><br><a href="https://blog.csdn.net/hollis_chuang/article/details/80728672?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159153974919724839223251%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=159153974919724839223251&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_v3-5-80728672.first_rank_ecpm_v1_pc_rank_v3&utm_term=%E6%9E%9A%E4%B8%BE%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B">为什么使用枚举</a></li>
</ol>
<p><a href="https://blog.csdn.net/qq_37358860/article/details/97673080?ops_request_misc=&request_id=&biz_id=102&utm_term=%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%B0%84%E7%A0%B4%E5%9D%8F%E5%8D%95%E4%BE%8B%20&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-97673080">如何防止反射机制和序列化反序列化破坏单例模式</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>设计模式-创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2020/06/05/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="原型模式-基本介绍"><a href="#原型模式-基本介绍" class="headerlink" title="原型模式-基本介绍"></a>原型模式-基本介绍</h3><p>基本介绍</p>
<ol>
<li>原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象</li>
<li>原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象， 无需知道如何创建的细节</li>
<li>工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 对象.clone()</li>
</ol>
<a id="more"></a>

<h4 id="克隆羊问题"><a href="#克隆羊问题" class="headerlink" title="克隆羊问题"></a>克隆羊问题</h4><p>现在有一只羊tom，姓名为: tom, 年龄为：1，颜色为：白色，请编写程序创建和tom<br>羊 属性完全相同的10只羊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cainiao.prototype;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ProjectName</span>: DesignPattern</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Package</span>: com.cainiao.prototype</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: sheep</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 铁板烤翅</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getColor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sheep</span><span class="params">(String name, <span class="keyword">int</span> age, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Sheep&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, color=&#x27;&quot;</span> + color + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sheep = (Sheep) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sheep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sheep sheep = <span class="keyword">new</span> Sheep(<span class="string">&quot;AA&quot;</span>,<span class="number">2</span>,<span class="string">&quot;白色&quot;</span>);</span><br><span class="line">        Sheep sheep1 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep sheep2 = (Sheep) sheep.clone();</span><br><span class="line">        Sheep sheep3 = (Sheep) sheep.clone();</span><br><span class="line">        System.out.println(sheep);</span><br><span class="line">        System.out.println(sheep2);</span><br><span class="line">        System.out.println(sheep3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="浅拷贝的介绍"><a href="#浅拷贝的介绍" class="headerlink" title="浅拷贝的介绍"></a>浅拷贝的介绍</h3><ol>
<li>对于数据类型是基本<strong>数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</strong></li>
<li>对于数据类型是<strong>引用数据类型的成员变量</strong>，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是<strong>只是将该成员变量的引用值（内存地址）复制一份给新的对象</strong>。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值</li>
<li>前面我们克隆羊就是浅拷贝</li>
<li>浅拷贝是使用默认的 clone()方法来实现<br>sheep = (Sheep) super.clone();<br><img src="https://img-blog.csdnimg.cn/20200604080202479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjExMTMwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
<h3 id="深拷贝基本介绍"><a href="#深拷贝基本介绍" class="headerlink" title="深拷贝基本介绍"></a>深拷贝基本介绍</h3><ol>
<li>复制对象的所有基本数据类型的成员变量值</li>
<li><strong>为所有引用数据类型的成员变量申请存储空间</strong>，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝</li>
<li>深拷贝实现方式1：<strong>重写clone方法来实现深拷贝</strong></li>
<li>深拷贝实现方式2：<strong>通过对象序列化实现深拷贝(推荐)</strong></li>
</ol>
<p><strong>重写clone方法来实现深拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Object deep = <span class="keyword">null</span>;</span><br><span class="line">		deep = <span class="keyword">super</span>.clone();</span><br><span class="line">		DeepProtoType deepProtoType = (DeepProtoType)deep;</span><br><span class="line">		<span class="comment">//直接拷贝引用数据类型</span></span><br><span class="line">		deepProtoType.deepCloneableTarget  = (DeepCloneableTarget)deepCloneableTarget.clone();</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> deepProtoType;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过对象序列化实现深拷贝</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		ByteArrayOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">		ByteArrayInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">			bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">			oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">			oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">			bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">			ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">			DeepProtoType copyObj = (DeepProtoType)ois.readObject();</span><br><span class="line">			<span class="keyword">return</span> copyObj;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				bos.close();</span><br><span class="line">				oos.close();</span><br><span class="line">				bis.close();</span><br><span class="line">				ois.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">				System.out.println(e2.getMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-创建型模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串匹配</title>
    <url>/2021/02/25/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h2 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a>BF算法</h2><p> 算法，简称 <strong>BF算法</strong>，是一种简单朴素的模式匹配算法，常用于在一个主串 S 内查找一个子串 T 的出现位置。</p>
<a id="more"></a>

<h3 id="核心思想与操作"><a href="#核心思想与操作" class="headerlink" title="核心思想与操作"></a>核心思想与操作</h3><ul>
<li>对于给定的主串 S 与子串 P ，主串 S 的长度为 N，子串 T 的长度为 M ；</li>
<li>首先，将 S[1] 和 T[1] 进行比较；</li>
<li>若相等，则再比较 S[2] 和 T[2] ，一直到 T[M] 为止；</li>
<li>若 S[1] 和 T[1] 不等，则 T 向右移动一个字符的位置，再依次进行比较；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">index</span><span class="params">( String S, String T, <span class="keyword">int</span> pos )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = pos;                        <span class="comment">// i 表示主串 S 中当前位置下标</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;                            <span class="comment">// j 表示子串 T 中当前位置下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( i &lt;= S[<span class="number">0</span>] &amp;&amp; j &lt;= T[<span class="number">0</span>] )&#123;    <span class="comment">// i 或 j 其中一个到达尾部则终止搜索</span></span><br><span class="line">        <span class="keyword">if</span>( S[i] == T[i] )&#123;             <span class="comment">// 若相等则继续进行下一个元素匹配</span></span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;                         <span class="comment">// 若匹配失败则 j 回溯到第一个元素重新匹配</span></span><br><span class="line">            i = i - j + <span class="number">2</span>;              <span class="comment">// 将 i 重新回溯到上次匹配首位的下一个元素</span></span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( j &gt; T[<span class="number">0</span>] )&#123;</span><br><span class="line">        <span class="keyword">return</span> i - T[<span class="number">0</span>];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>详解Java中的clone方法 -- 原型模式应用</title>
    <url>/2020/06/05/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>在 Java 开发中，对象拷贝或者说对象克隆是常有的事，对象克隆最终都离不开<strong>直接赋值</strong>、<strong>浅拷贝</strong>、<strong>深拷贝</strong> 这三种方式，其中直接赋值应该是我们最常用的一种方式吧，对于浅拷贝和深拷贝可能用的少，所以或多或少存在一些误区，这篇文章会详细的介绍这三种对象克隆方式。</p>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><a id="more"></a>

<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">值类型：Java 的基本数据类型，例如 int、float </span><br><span class="line">引用类型：自定义类和 Java 包装类（string、integer）</span><br></pre></td></tr></table></figure>
<h2 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h2><p>直接赋值是我们最常用的方式，在我们代码中的体现是<code>Persona = new Person();Person b = a</code>，是一种简单明了的方式，但是它只是拷贝了对象引用地址而已，并没有在内存中生成新的对象，我们可以通过下面这个例子来证明这一点</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// person 对象</span><br><span class="line">public class Person &#123;</span><br><span class="line">    // 姓名</span><br><span class="line">    private String name;</span><br><span class="line">    // 年龄</span><br><span class="line">    private int age;</span><br><span class="line">    // 邮件</span><br><span class="line">    private String email;</span><br><span class="line">    // 描述</span><br><span class="line">    private String desc;</span><br><span class="line">    ...省略get/set...</span><br><span class="line"> &#125;</span><br><span class="line"> // main 方法</span><br><span class="line">public class PersonApp &#123;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       // 初始化一个对象</span><br><span class="line">       Person person = new Person(&quot;张三&quot;,20,&quot;123456@qq.com&quot;,&quot;我是张三&quot;);</span><br><span class="line">       // 复制对象</span><br><span class="line">       Person person1 = person;</span><br><span class="line">       // 改变 person1 的属性值</span><br><span class="line">       person1.setName(&quot;我不是张三了&quot;);</span><br><span class="line">        System.out.println(&quot;person对象：&quot;+person);</span><br><span class="line">        System.out.println(&quot;person1对象：&quot;+person1);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面代码，你会得到如下结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">person对象：Person&#123;name=&#x27;我不是张三了&#x27;, age=20, email=&#x27;123456@qq.com&#x27;, desc=&#x27;我是张三&#x27;&#125;</span><br><span class="line">person1对象：Person&#123;name=&#x27;我不是张三了&#x27;, age=20, email=&#x27;123456@qq.com&#x27;, desc=&#x27;我是张三&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>我们将 person 对象复制给了 person1 对象，我们对 person1 对象的 name 属性进行了修改，并未修改 person 对象的name 属性值，但是我们最后发现 person 对象的 name 属性也发生了变化，其实不止这一个值，对于其他值也是一样的，所以这结果证明了我们上面的结论：<strong>直接赋值的方式没有生产新的对象，只是生新增了一个对象引用</strong>，直接赋值在 Java 内存中的模型大概是这样的</p>
<p><img src="https://pic1.zhimg.com/80/v2-8d4e2cd8ebace73fce4c274ea19078bc_720w.jpg" alt="img"></p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>浅拷贝也可以实现对象克隆，从这名字你或许可以知道，这种拷贝一定存在某种缺陷，是的，它就是存在一定的缺陷，先来看看浅拷贝的定义：<strong>如果原型对象的成员变量是值类型，将复制一份给克隆对象，也就是说在堆中拥有独立的空间；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。换句话说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。</strong> 可能你没太理解这段话，那么我们在来看看浅拷贝的通用模型：</p>
<p><img src="https://pic1.zhimg.com/80/v2-bd3f6d4f20cac8acee4b2548783884c4_720w.jpg" alt="img"></p>
<p>要实现对象浅拷贝还是比较简单的，只需要被复制类需要实现 Cloneable 接口，重写 clone 方法即可，对 person 类进行改造，使其可以支持浅拷贝。</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public class Person implements Cloneable &#123;</span><br><span class="line">    // 姓名</span><br><span class="line">    private String name;</span><br><span class="line">    // 年龄</span><br><span class="line">    private int age;</span><br><span class="line">    // 邮件</span><br><span class="line">    private String email;</span><br><span class="line">    // 描述</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * 重写 clone 方法，需要将权限改成 public ，直接调用父类的 clone 方法就好了</span><br><span class="line">    */</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    ...省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造很简单只需要让 person 继承 Cloneable 接口，并且重写 clone 方法即可，clone 也非常简单只需要调用 object 的 clone 方法就好，唯一需要注意的地方就是 clone 方法需要用 public 来修饰，在简单的修改 main 方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public class PersonApp &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 初始化一个对象</span><br><span class="line">        Person person = new Person(&quot;张三&quot;,20,&quot;123456@qq.com&quot;,&quot;我是张三&quot;);</span><br><span class="line">        // 复制对象</span><br><span class="line">        Person person1 = (Person) person.clone();</span><br><span class="line">        // 改变 person1 的属性值</span><br><span class="line">        person1.setName(&quot;我是张三的克隆对象&quot;);</span><br><span class="line">        // 修改 person age 的值</span><br><span class="line">        person1.setAge(22);</span><br><span class="line">        System.out.println(&quot;person对象：&quot;+person);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;person1对象：&quot;+person1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新运行 main 方法，结果如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">person对象：Person&#123;name=&#x27;张三&#x27;, age=20, email=&#x27;123456@qq.com&#x27;, desc=&#x27;我是张三&#x27;&#125;</span><br><span class="line"></span><br><span class="line">person1对象：Person&#123;name=&#x27;我是张三的克隆对象&#x27;, age=22, email=&#x27;123456@qq.com&#x27;, desc=&#x27;我是张三&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>看到这个结果，你是否有所质疑呢？说好的引用对象只是拷贝了地址，为啥修改了 person1 对象的 name 属性值，person 对象没有改变？这里就是一个非常重要的知识点了，，原因在于：<strong>String、Integer 等包装类都是不可变的对象，当需要修改不可变对象的值时，需要在内存中生成一个新的对象来存放新的值，然后将原来的引用指向新的地址，所以在这里我们修改了 person1 对象的 name 属性值，person1 对象的 name 字段指向了内存中新的 name 对象，但是我们并没有改变 person 对象的 name 字段的指向，所以 person 对象的 name 还是指向内存中原来的 name 地址，也就没有变化</strong></p>
<p>这种引用是一种特列，因为这些引用具有不可变性，并不具备通用性，所以我们就自定义一个类，来演示浅拷贝，我们定义一个 PersonDesc 类用来存放person 对象中的 desc 字段，，然后在 person 对象中引用 PersonDesc 类，具体代码如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">// 新增 PersonDesc </span><br><span class="line">public class PersonDesc &#123;</span><br><span class="line">    // 描述</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class Person implements Cloneable &#123;</span><br><span class="line">    // 姓名</span><br><span class="line">    private String name;</span><br><span class="line">    // 年龄</span><br><span class="line">    private int age;</span><br><span class="line">    // 邮件</span><br><span class="line">    private String email;</span><br><span class="line">    // 将原来的 string desc 变成了 PersonDesc 对象，这样 personDesc 就是引用类型</span><br><span class="line">    private PersonDesc personDesc;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    public void setDesc(String desc) &#123;</span><br><span class="line">        this.personDesc.setDesc(desc);</span><br><span class="line">    &#125;</span><br><span class="line">    public Person(String name, int age, String email, String desc) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">        this.email = email;</span><br><span class="line">        this.personDesc = new PersonDesc();</span><br><span class="line">        this.personDesc.setDesc(desc);</span><br><span class="line">    &#125;</span><br><span class="line">     ...省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 main 方法</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public class PersonApp &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 初始化一个对象</span><br><span class="line">        Person person = new Person(&quot;平头&quot;,20,&quot;123456@qq.com&quot;,&quot;技术&quot;);</span><br><span class="line">        // 复制对象</span><br><span class="line">        Person person1 = (Person) person.clone();</span><br><span class="line">        // 改变 person1 的属性值</span><br><span class="line">        person1.setName(&quot;我是平头的克隆对象&quot;);</span><br><span class="line">        // 修改 person age 的值</span><br><span class="line">        person1.setAge(22);</span><br><span class="line">        person1.setDesc(&quot;我已经关注了技术&quot;);</span><br><span class="line">        System.out.println(&quot;person对象：&quot;+person);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;person1对象：&quot;+person1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 main 方法，得到如下结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">person对象：Person&#123;name=&#x27;平头&#x27;, age=20, email=&#x27;123456@qq.com&#x27;, desc=&#x27;我已经关注了技术&#x27;&#125;</span><br><span class="line"></span><br><span class="line">person1对象：Person&#123;name=&#x27;我是平头的克隆对象&#x27;, age=22, email=&#x27;123456@qq.com&#x27;, desc=&#x27;我已经关注了技术&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>我们修改 person1 的 desc 字段之后，person 的 desc 也发生了改变，这说明 person 对象和 person1 对象指向是同一个 PersonDesc 对象地址，这也符合浅拷贝引用对象只拷贝引用地址并未创建新对象的定义，到这你应该知道浅拷贝了吧。</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>深拷贝也是对象克隆的一种方式，相对于浅拷贝，<strong>深拷贝是一种完全拷贝，无论是值类型还是引用类型都会完完全全的拷贝一份，在内存中生成一个新的对象</strong>，简单点说就是拷贝对象和被拷贝对象没有任何关系，互不影响。深拷贝的通用模型如下：</p>
<p><img src="https://pic1.zhimg.com/80/v2-cb4cb526cc8a637848ad2ad176d50d40_720w.jpg" alt="img"></p>
<p>深拷贝有两种方式，一种是跟浅拷贝一样实现 Cloneable 接口，另一种是实现 Serializable 接口，用序列化的方式来实现深拷贝，我们分别用这两种方式来实现深拷贝</p>
<h3 id="实现-Cloneable-接口方式"><a href="#实现-Cloneable-接口方式" class="headerlink" title="实现 Cloneable 接口方式"></a>实现 Cloneable 接口方式</h3><p>实现 Cloneable 接口的方式跟浅拷贝相差不大，我们需要引用对象也实现 Cloneable 接口，具体代码改造如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public class PersonDesc implements Cloneable&#123;</span><br><span class="line"></span><br><span class="line">    // 描述</span><br><span class="line">    private String desc;</span><br><span class="line">    ...省略...</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        return super.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Person implements Cloneable &#123;</span><br><span class="line">    // 姓名</span><br><span class="line">    private String name;</span><br><span class="line">    // 年龄</span><br><span class="line">    private int age;</span><br><span class="line">    // 邮件</span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">    private PersonDesc personDesc;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * clone 方法不是简单的调用super的clone 就好，</span><br><span class="line">    */</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Person person = (Person)super.clone();</span><br><span class="line">        // 需要将引用对象也克隆一次</span><br><span class="line">        person.personDesc = (PersonDesc) personDesc.clone();</span><br><span class="line">        return person;</span><br><span class="line">    &#125;</span><br><span class="line">    ...省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main 方法不需要任何改动，我们再次运行 main 方法，得到如下结果：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">person对象：Person&#123;name=&#x27;平头&#x27;, age=20, email=&#x27;123456@qq.com&#x27;, desc=&#x27;技术&#x27;&#125;</span><br><span class="line"></span><br><span class="line">person1对象：Person&#123;name=&#x27;平头的克隆对象&#x27;, age=22, email=&#x27;123456@qq.com&#x27;, desc=&#x27;我已经关注了技术&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，修改 person1 的 desc 时对 person 的 desc 已经没有影响了，说明进行了深拷贝，在内存中重新生成了一个新的对象。</p>
<h3 id="实现-Serializable-接口方式"><a href="#实现-Serializable-接口方式" class="headerlink" title="实现 Serializable 接口方式"></a>实现 Serializable 接口方式</h3><p>实现 Serializable 接口方式也可以实现深拷贝，而且这种方式还可以解决多层克隆的问题，多层克隆就是引用类型里面又有引用类型，层层嵌套下去，用 Cloneable 方式实现还是比较麻烦的，一不小心写错了就不能实现深拷贝了，使用 Serializable 序列化的方式就需要所有的对象对实现 Serializable 接口，我们对代码进行改造，改造成序列化的方式</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">public class Person implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 369285298572941L;</span><br><span class="line">    // 姓名</span><br><span class="line">    private String name;</span><br><span class="line">    // 年龄</span><br><span class="line">    private int age;</span><br><span class="line">    // 邮件</span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">    private PersonDesc personDesc;</span><br><span class="line"></span><br><span class="line">    public Person clone() &#123;</span><br><span class="line">        Person person = null;</span><br><span class="line">        try &#123; // 将该对象序列化成流,因为写在流里的是对象的一个拷贝，而原对象仍然存在于JVM里面。所以利用这个特性可以实现对象的深拷贝</span><br><span class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = new ObjectOutputStream(baos);</span><br><span class="line">            oos.writeObject(this);</span><br><span class="line">            // 将流序列化成对象</span><br><span class="line">            ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = new ObjectInputStream(bais);</span><br><span class="line">            person = (Person) ois.readObject();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return person;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDesc(String desc) &#123;</span><br><span class="line">        this.personDesc.setDesc(desc);</span><br><span class="line">    &#125;</span><br><span class="line">  ...省略...</span><br><span class="line">&#125;</span><br><span class="line">public class PersonDesc implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 872390113109L; </span><br><span class="line">    // 描述</span><br><span class="line">    private String desc;</span><br><span class="line"></span><br><span class="line">    public String getDesc() &#123;</span><br><span class="line">        return desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDesc(String desc) &#123;</span><br><span class="line">        this.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">public class PersonApp &#123;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 初始化一个对象</span><br><span class="line">        Person person = new Person(&quot;平头&quot;,20,&quot;123456@qq.com&quot;,&quot;技术&quot;);</span><br><span class="line">        // 复制对象</span><br><span class="line">        Person person1 = (Person) person.clone();</span><br><span class="line">        // 改变 person1 的属性值</span><br><span class="line">        person1.setName(&quot;我是平头的克隆对象&quot;);</span><br><span class="line">        // 修改 person age 的值</span><br><span class="line">        person1.setAge(22);</span><br><span class="line">        person1.setDesc(&quot;我已经关注了技术&quot;);</span><br><span class="line">        System.out.println(&quot;person对象：&quot;+person);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(&quot;person1对象：&quot;+person1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 main 方法，我们可以得到跟 Cloneable 方式一样的结果，序列化的方式也实现了深拷贝。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>原码</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2020/06/07/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h3><ol>
<li><p>作用：实现创建者和使用者的分离</p>
</li>
<li><p>核心本质：</p>
<p> 实例对象不用new，用工厂方法代替<br> 将选择实现类，创建对象统一管理和控制，从而将我们的调用者和实现类解耦</p>
</li>
</ol>
<a id="more"></a>

<h3 id="简单工厂模式（静态工厂方法-Static-Factory-Method-模式）"><a href="#简单工厂模式（静态工厂方法-Static-Factory-Method-模式）" class="headerlink" title="简单工厂模式（静态工厂方法(Static Factory Method)模式）"></a>简单工厂模式（静态工厂方法(Static Factory Method)模式）</h3><ol>
<li>优点是比较好理解，简单易操作。</li>
<li>缺点是违反了设计模式的ocp原则（开闭原则），即对扩展开放，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方式一：增加车辆C需要改代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String car)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (car.equals(<span class="string">&quot;A&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (car.equals(<span class="string">&quot;B&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> B();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方式二(优化不改逻辑)：增加车辆C需要改代码</span></span><br><span class="line">    <span class="comment">//public static Car carA()&#123;</span></span><br><span class="line">    <span class="comment">//    return new A();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//public static Car carB()&#123;</span></span><br><span class="line">    <span class="comment">//    return new B();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用工厂</span></span><br><span class="line">        Car a = Factory.getCar(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        a.name();</span><br><span class="line">        Car b = Factory.getCar(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        b.name();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Car carA = Factory.carA();</span></span><br><span class="line">        <span class="comment">//carA.name();</span></span><br><span class="line">        <span class="comment">//Car carB = Factory.carA();</span></span><br><span class="line">        <span class="comment">//carB.name();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="简单工厂模式的优点"><a href="#简单工厂模式的优点" class="headerlink" title="简单工厂模式的优点"></a>简单工厂模式的优点</h4><ol>
<li>工厂类<strong>含有必要的判断逻辑</strong>，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它<strong>提供了专门的工厂类用于创建对象</strong>。</li>
<li>客户端<strong>无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可</strong>，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li>
<li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。（我没有使用过，具体啥情况不了解）</li>
</ol>
<h4 id="简单工厂模式的缺点"><a href="#简单工厂模式的缺点" class="headerlink" title="简单工厂模式的缺点"></a>简单工厂模式的缺点</h4><ol>
<li>由于工厂类<strong>集中了所有产品创建逻辑</strong>，<strong>一旦不能正常工作，整个系统都要受到影响。</strong></li>
<li>使用简单工厂模式将会<strong>增加系统中类的个数</strong>，在一定程序上增加了系统的复杂度和理解难度。</li>
<li><strong>系统扩展困难</strong>，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li>
<li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li>
</ol>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p>
<pre><code>Product：抽象产品
ConcreteProduct：具体产品
Factory：抽象工厂
ConcreteFactory：具体工厂
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**抽象产品**</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**具体产品**</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;A车&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**抽象工厂**</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryInter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getcar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**具体工厂**</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AFactory</span> <span class="keyword">implements</span> <span class="title">FactoryInter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getcar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AFactory aFactory = <span class="keyword">new</span> AFactory();</span><br><span class="line">        Car getcar = aFactory.getcar();</span><br><span class="line">        getcar.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="工厂方法模式的优点优点"><a href="#工厂方法模式的优点优点" class="headerlink" title="工厂方法模式的优点优点"></a>工厂方法模式的优点优点</h4><p>   (1) 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，<strong>用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</strong></p>
<p>   (2) 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。<strong>工厂方法模式之所以又被称为多态工厂模式</strong>，就正是因为所有的具体工厂类都具有同一抽象父类。</p>
<p>   (3) 使用工厂方法模式的另一个优点是<strong>在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</strong></p>
<h4 id="工厂方法模式的缺点"><a href="#工厂方法模式的缺点" class="headerlink" title="工厂方法模式的缺点"></a>工厂方法模式的缺点</h4><p> (1) <strong>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类(每个产品对应一个工厂类)，系统中类的个数将成对增加</strong>，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</p>
<p>   (2) 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</p>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>
<pre><code>AbstractFactory：抽象工厂
ConcreteFactory：具体工厂
AbstractProduct：抽象产品
Product：具体产品
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**AbstractProduct：抽象产品**</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callPhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IpadProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**Product：具体产品**</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiaomiPhone</span> <span class="keyword">implements</span> <span class="title">PhoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSMS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米发送短信&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米打电话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiaomiIpad</span> <span class="keyword">implements</span> <span class="title">IpadProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米ipad开机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米ipad关机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**AbstractFactory：抽象工厂**</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PhoneProduct <span class="title">productphone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpadProduct <span class="title">productIpad</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> **ConcreteFactory：具体工厂**</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">xiaomiFactory</span> <span class="keyword">implements</span> <span class="title">ProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PhoneProduct <span class="title">productphone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> xiaomiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IpadProduct <span class="title">productIpad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> xiaomiIpad();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        xiaomiFactory xiaomi = <span class="keyword">new</span> xiaomiFactory();</span><br><span class="line">        PhoneProduct productphone = xiaomi.productphone();</span><br><span class="line">        productphone.callPhone();</span><br><span class="line">        productphone.sendSMS();</span><br><span class="line">        IpadProduct ipadProduct = xiaomi.productIpad();</span><br><span class="line">        ipadProduct.start();</span><br><span class="line">        ipadProduct.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">小米打电话</span><br><span class="line">小米发送短信</span><br><span class="line">小米ipad开机</span><br><span class="line">小米ipad关机</span><br></pre></td></tr></table></figure>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>抽象工厂模式隔离了具体类的生成，使得<strong>客户并不需要知道什么被创建</strong>。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，<strong>应用抽象工厂模式可以实现高内聚低耦合的设计目的</strong>，因此抽象工厂模式得到了广泛的应用。</li>
<li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式。</li>
<li>增加新的具体工厂和产品族很方便，<strong>无须修改已有系统，符合“开闭原则”</strong>。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将<strong>涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。</strong></li>
<li>开闭原则的倾斜性（<strong>增加新的工厂和产品族容易</strong>，<strong>增加新的产品等级结构麻烦</strong>）。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li><p> 抽象工厂模式提供一个创建一系列相关或相互依赖对象的<strong>接口</strong>，而<strong>无须指定它们具体的类</strong>。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p>
</li>
<li><p><strong>抽象工厂模式包含四个角色</strong>：</p>
<pre><code> （1）**抽象工厂**用于声明生成抽象产品的方法；
 （2）**具体工厂**实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；
 （3）**抽象产品**为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；
 （4）**具体产品**定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。
</code></pre>
</li>
<li><p> 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。抽象工厂模式与工厂方法模式最大的区别在于，<strong>工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构</strong>。</p>
</li>
<li><p>抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，<strong>增加或者替换产品族比较方便</strong>，<strong>增加新的具体工厂和产品族很方便</strong>；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。</p>
</li>
<li><p>抽象工厂模式适用情况包括：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，而每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用；系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-创建型模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2020/06/06/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<a id="more"></a>

<p>建造者模式是一步一步创建一个复杂的对象，它<strong>允许用户只通过指定复杂对象的类型和内容就可以构建它们</strong>，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。</p>
<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p>建造者模式包含如下角色：</p>
<pre><code>Builder：抽象建造者
ConcreteBuilder：具体建造者
Director：指挥者
Product：产品角色
</code></pre>
<p>  <strong>抽象建造者</strong>为创建一个产品对象的各个部件指定抽象接口；<br>  <strong>具体建造者</strong>实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；<br>  <strong>产品角色</strong>是被构建的复杂对象，包含多个组成部件；<br>  <strong>指挥者负责</strong>安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象得建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildC</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildD</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Product <span class="title">getproduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//具体建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product = <span class="keyword">new</span> Product();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setBuildA(<span class="string">&quot;A步骤&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;A步骤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setBuildB(<span class="string">&quot;B步骤&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;B步骤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setBuildC(<span class="string">&quot;C步骤&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;C步骤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setBuildC(<span class="string">&quot;C步骤&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;C步骤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Product <span class="title">getproduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String buildA;</span><br><span class="line">    <span class="keyword">private</span> String buildB;</span><br><span class="line">    <span class="keyword">private</span> String buildC;</span><br><span class="line">    <span class="keyword">private</span> String buildD;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBuildA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuildA</span><span class="params">(String buildA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buildA = buildA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBuildB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuildB</span><span class="params">(String buildB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buildB = buildB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBuildC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuildC</span><span class="params">(String buildC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buildC = buildC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBuildD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuildD</span><span class="params">(String buildD)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buildD = buildD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Product&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;buildA=&#x27;&quot;</span> + buildA + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, buildB=&#x27;&quot;</span> + buildB + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, buildC=&#x27;&quot;</span> + buildC + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, buildD=&#x27;&quot;</span> + buildD + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//核心，负责指挥构建一个工程，工程建造顺序由它决定</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        builder.buildA();</span><br><span class="line">        builder.buildB();</span><br><span class="line">        builder.buildC();</span><br><span class="line">        builder.buildD();</span><br><span class="line">        <span class="keyword">return</span> builder.getproduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200604111837616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjExMTMwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="指挥者交给客户端"><a href="#指挥者交给客户端" class="headerlink" title="指挥者交给客户端"></a>指挥者交给客户端</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象得建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">buildA</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">buildB</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">buildC</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">buildD</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Product <span class="title">getproduct</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//具体建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product = <span class="keyword">new</span> Product();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">buildA</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setBuildA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">buildB</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setBuildB(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">buildC</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setBuildC(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">buildD</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setBuildD(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Product <span class="title">getproduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String buildA = <span class="string">&quot;汉堡&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String buildB = <span class="string">&quot;薯条&quot;</span> ;</span><br><span class="line">    <span class="keyword">private</span> String buildC = <span class="string">&quot;可乐&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String buildD = <span class="string">&quot;甜品&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBuildA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuildA</span><span class="params">(String buildA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buildA = buildA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBuildB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuildB</span><span class="params">(String buildB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buildB = buildB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBuildC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuildC</span><span class="params">(String buildC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buildC = buildC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBuildD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuildD</span><span class="params">(String buildD)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buildD = buildD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Product&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;buildA=&#x27;&quot;</span> + buildA + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, buildB=&#x27;&quot;</span> + buildB + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, buildC=&#x27;&quot;</span> + buildC + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, buildD=&#x27;&quot;</span> + buildD + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteBuilder concreteBuilder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Product product = concreteBuilder.getproduct();</span><br><span class="line">        System.out.println(product);</span><br><span class="line">        <span class="comment">//在原有套餐进行组合修改</span></span><br><span class="line">        product.setBuildA(<span class="string">&quot;披萨&quot;</span>);</span><br><span class="line">        System.out.println(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200604105832123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjExMTMwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li><strong>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者</strong>， 用户使用不同的具体建造者即可得到不同的产品对象 。</li>
<li>可以更加<strong>精细地控制产品的创建过程</strong> 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，<strong>符合“开闭原则”</strong>。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>建造者模式所创建的<strong>产品一般具有较多的共同点，其组成部分相似</strong>，如果产品之间的<strong>差异性很大，则不适合使用建造者模式</strong>，因此其使用范围受到一定的限制。</li>
<li>如果产品的<strong>内部变化复杂，</strong>可能会导致需要定义很多具体建造者类来实现这种变化，<strong>导致系统变得很庞大</strong>。</li>
</ol>
<h2 id="建造者模式与抽象工厂模式的比较"><a href="#建造者模式与抽象工厂模式的比较" class="headerlink" title="建造者模式与抽象工厂模式的比较:"></a>建造者模式与抽象工厂模式的比较:</h2><ol>
<li>与抽象工厂模式相比， <strong>建造者模式返回一个组装好的完整产品 ，而 抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</strong></li>
<li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li>
<li>如果将抽象工厂模式看成 <strong>汽车配件生产工厂</strong> ，生产一个产品族的产品，那么建造者模式就是一个 <strong>汽车组装工厂</strong> ，通过对部件的组装可以返回一辆完整的汽车。</li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>异常处理</title>
    <url>/2021/03/04/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>待完善。。。</p>
<p>方式一：</p>
<p> @ExceptionHandler和@ControllerAdvic（控制器异常）组合注解</p>
<p>方式二：</p>
<p>ErrorController（所有异常）</p>
<a id="more"></a>]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/02/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>排序也称排序算法(Sort Algorithm)，排序是将一组数据，依指定的顺序进行排列的过程。<br>排序的分类：</p>
<ol>
<li><p>内部排序:<br>指将需要处理的所有数据都加载到内部存储器中进行排序。<a id="more"></a></p>
</li>
<li><p>外部排序法：<br>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。</p>
</li>
<li><p>常见的排序算法分类(见图):<br><img src="https://img-blog.csdnimg.cn/20200605125439892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjExMTMwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</li>
</ol>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210224164306638.png" alt="image-20210224164306638"></p>
<h4 id="关于时间复杂度："><a href="#关于时间复杂度：" class="headerlink" title="关于时间复杂度："></a>关于时间复杂度：</h4><ol>
<li>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。</li>
<li>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；</li>
<li>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序</li>
<li>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</li>
</ol>
<h4 id="关于稳定性："><a href="#关于稳定性：" class="headerlink" title="关于稳定性："></a>关于稳定性：</h4><ol>
<li>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</li>
<li>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</li>
</ol>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BibbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,-<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>增加判断</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BibbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,-<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;arr.length-i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    temp = arr[j];</span><br><span class="line">                    arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                    arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;次排序&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">            <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ul>
<h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort1</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">      	<span class="comment">//在推导的过程，我们发现了规律，因此，可以使用for来解决</span></span><br><span class="line">      	<span class="comment">//选择排序时间复杂度是 O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">int</span> min = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &gt; arr[j]) &#123; <span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">                    min = arr[j]; <span class="comment">// 重置min</span></span><br><span class="line">                    minIndex = j; <span class="comment">// 重置minIndex</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将最小值，放在arr[0], 即交换</span></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">                arr[minIndex] = arr[i];</span><br><span class="line">                arr[i] = min;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//System.out.println(&quot;第&quot;+(i+1)+&quot;轮后~~&quot;);</span></span><br><span class="line">            <span class="comment">//System.out.println(Arrays.toString(arr));</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul>
<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>
<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>
</ul>
<p>插入排序从第二个数开始，拿出第二个数进行向前插入排序，一直到最后一个数向前做插入排序。算法稳定。</p>
<p>插入排序的时间复杂度为O(n2)，空间复杂度为O(1)。最好的时间复杂度是O(n)，最坏也就是平均是O(n2)<br><a href="https://blog.csdn.net/qq_41055045/article/details/103463918?ops_request_misc=%7B%22request_id%22:%22160799154016780308311607%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=160799154016780308311607&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-103463918.nonecase&utm_term=%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&spm=1018.2118.3001.4449">插入排序理解</a></p>
<h4 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">80</span>,<span class="number">45</span>, <span class="number">100</span>, <span class="number">66</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">//要插入的数据</span></span><br><span class="line">        <span class="keyword">int</span> insertValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> insertIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            insertValue = arr[i];</span><br><span class="line">            <span class="comment">//要比较的位置</span></span><br><span class="line">            insertIndex= i-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (insertIndex&gt;=<span class="number">0</span>&amp;&amp;insertValue&lt;arr[insertIndex])&#123;</span><br><span class="line">                arr[insertIndex+<span class="number">1</span>] = arr[insertIndex];<span class="comment">//80,80</span></span><br><span class="line">                insertIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[insertIndex+<span class="number">1</span>] = insertValue;<span class="comment">//45,80</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span>+i+<span class="string">&quot;轮后~~&quot;</span>);</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h4 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul>
<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<p>希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。<br><strong>交换法</strong>（比原有插入排序还要慢）【分组,间隔gap变化冒泡排序】</p>
<h4 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellExhangeShort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                        temp = arr[j];</span><br><span class="line">                        arr[j] = arr[j + gap];</span><br><span class="line">                        arr[j + gap] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (++count) + <span class="string">&quot;次：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>移动法</strong>（优化）[效率高]【分组,间隔gap变化冒泡排序插入排序】</p>
<h4 id="参考代码-4"><a href="#参考代码-4" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellMoveSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> tempValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                tempValue = arr[index];</span><br><span class="line">                <span class="keyword">if</span> (arr[index] &lt; arr[index - gap]) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (index - gap &gt;= <span class="number">0</span> &amp;&amp; tempValue &lt; arr[index - gap]) &#123;</span><br><span class="line">                        arr[index] = arr[index-gap];</span><br><span class="line">                        index -= gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    arr[index] = tempValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + (++count) + <span class="string">&quot;次：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）中心轴;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ul>
<p><strong>比希尔排序（移动法）效率更高</strong><br>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列<br><a href="https://www.bilibili.com/video/BV1at411T75o?from=search&seid=6928466144757802796">秒懂算法</a></p>
<p>参考代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Quicksort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">45</span>,<span class="number">78</span>,<span class="number">0</span>,<span class="number">23</span>,-<span class="number">567</span>,<span class="number">30</span>&#125;;</span><br><span class="line">        Quicksort(arr,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Quicksort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L&gt;R)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> left = L,right = R;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[left];</span><br><span class="line">        <span class="keyword">while</span> (left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">while</span> (left&lt;right&amp;&amp;arr[right]&gt;=pivot)&#123;</span><br><span class="line">                right--;<span class="comment">//左移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">                arr[left]=arr[right];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (left&lt;right&amp;&amp;arr[left]&lt;=pivot)&#123;</span><br><span class="line">                left++;<span class="comment">//右移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left&lt;right)&#123;</span><br><span class="line">                arr[right]=arr[left];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (right==left)&#123;</span><br><span class="line">                arr[left]=pivot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Quicksort(arr,L,right-<span class="number">1</span>);</span><br><span class="line">        Quicksort(arr, right+<span class="number">1</span>, R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h4 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h4><ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul>
<h4 id="参考代码-5"><a href="#参考代码-5" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123; <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span> &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>, temp);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分+合方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">//中间索引</span></span><br><span class="line">            <span class="comment">//向左递归进行分解</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归进行分解</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            merge(arr, left, mid, right, temp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//合并的方法</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 排序的原始数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid 中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp 做中转的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = left; <span class="comment">// 初始化i, 左边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">//初始化j, 右边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>; <span class="comment">// 指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//(一)</span></span><br><span class="line">        <span class="comment">//先把左右两边(有序)的数据按照规则填充到temp数组</span></span><br><span class="line">        <span class="comment">//直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;<span class="comment">//继续</span></span><br><span class="line">            <span class="comment">//如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line">            <span class="comment">//即将左边的当前元素，填充到 temp数组</span></span><br><span class="line">            <span class="comment">//然后 t++, i++</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                i += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//反之,将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t += <span class="number">1</span>;</span><br><span class="line">                j += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(二)</span></span><br><span class="line">        <span class="comment">//把有剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line">        <span class="keyword">while</span>( i &lt;= mid) &#123; <span class="comment">//左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            i += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( j &lt;= right) &#123; <span class="comment">//右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            j += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//(三)【有点迷糊】</span></span><br><span class="line">        <span class="comment">//将temp数组的元素拷贝到arr</span></span><br><span class="line">        <span class="comment">//注意，并不是每次都拷贝所有</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempLeft = left; <span class="comment">//</span></span><br><span class="line">        <span class="comment">//第一次合并 tempLeft = 0 , right = 1 //  tempLeft = 2  right = 3 // tL=0 ri=3</span></span><br><span class="line">        <span class="comment">//最后一次 tempLeft = 0  right = 7</span></span><br><span class="line">        <span class="keyword">while</span>(tempLeft &lt;= right) &#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            t += <span class="number">1</span>;</span><br><span class="line">            tempLeft += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a><strong>基数排序</strong></h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&mid=2247485556&idx=1&sn=344738dd74b211e091f8f3477bdf91ee&chksm=fa0e67f5cd79eee3139d4667f3b94fa9618067efc45a797b69b41105a7f313654d0e86949607&scene=21#wechat_redirect">排序算法参考</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/2021/02/22/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。</p>
<ul>
<li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li>
<li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</li>
</ul>
<a id="more"></a>]]></content>
      <categories>
        <category>基础复习</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>简易秒杀整理</title>
    <url>/2021/03/15/%E7%A7%92%E6%9D%80%E9%80%BB%E8%BE%91%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p>springboot,mybatis,redis,md5,令牌算法</p>
<h3 id="超卖问题："><a href="#超卖问题：" class="headerlink" title="超卖问题："></a>超卖问题：</h3><p>防止卖出数量大于秒杀库存数量</p>
<a id="more"></a>

<p>解决方式一：悲观锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//同步代码块保证秒杀安全</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> orderId = orderService.kill(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;秒杀成功，订单id = &quot;</span>+String.valueOf(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个请求都加锁，严重影响性能</p>
<p>解决方式二：乐观锁</p>
<p>在数据库层面同时更新销量和版本，在插入数据时根据id读取的库存和版本判断进行更新</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据id查库存</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Stock <span class="title">checkStockMethod</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    Stock stock = stockDAO.checkStock(id);</span><br><span class="line">    <span class="keyword">if</span>(stock.getCount().equals(stock.getSale()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateSaleMethod</span><span class="params">(Stock stock)</span></span>&#123;</span><br><span class="line">    <span class="comment">//在sql层面对销量+1,版本+1;</span></span><br><span class="line">    <span class="keyword">int</span> cow = stockDAO.OptimisticupdateSale(stock);</span><br><span class="line">    <span class="keyword">if</span> (cow==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;抢购失败,请重试&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span>update id<span class="operator">=</span>&quot;OptimisticupdateSale&quot; parameterType<span class="operator">=</span>&quot;Stock&quot;<span class="operator">&gt;</span></span><br><span class="line">    update tb_newbee_mall_ms <span class="keyword">set</span></span><br><span class="line">        sale <span class="operator">=</span> sale<span class="operator">+</span><span class="number">1</span>,</span><br><span class="line">        version <span class="operator">=</span> version<span class="operator">+</span><span class="number">1</span></span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        id = #&#123;id&#125;</span><br><span class="line">        <span class="keyword">and</span></span><br><span class="line">        version = #&#123;version&#125;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span>update<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>漏桶算法（漏斗算法）、令牌算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建令牌10个</span></span><br><span class="line"><span class="keyword">private</span> RateLimiter rateLimiter = RateLimiter.create(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置令牌时间限流</span></span><br><span class="line"><span class="keyword">if</span>(!rateLimiter.tryAcquire(<span class="number">5</span>, TimeUnit.SECONDS))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前请求限流，直接抛弃&quot;</span>+rateLimiter.acquire());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;抢购失败&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口隐藏"><a href="#接口隐藏" class="headerlink" title="接口隐藏"></a>接口隐藏</h3><p>​    用户在下单前，先发出一个生成md5hash值的请求，根据自己抢购的商品id和自己的用户Id用Md5加密算法和随机盐生成一个hash值存到redis中，在redis中设置过期时间，等用户真正下单时发起的下单请求（秒杀请求）携带着Md5的hash值和redis中已经存在的hash值作比较是否相等，就能判断此请求是根据脚本发起的请求（没有点击抢购秒杀按钮）还是用户在app下下的单了，避免一些用户的脚本抢购,如果两次md5的值相等，那么就处理下单业务，如果不相等，那么就抛弃请求。</p>
<p><img src="https://img-blog.csdnimg.cn/20200806202515289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RzbDU5NzQx,size_16,color_FFFFFF,t_70" alt="image-20210317091757714"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成MD5并存入Redis，设置过期时间</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMD5</span><span class="params">(Integer id, Integer userid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检测用户存合法性</span></span><br><span class="line">    User user = userDao.findByid(userid);</span><br><span class="line">    <span class="keyword">if</span>(user==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;用户信息&#123;&#125;:&quot;</span>,user.toString());</span><br><span class="line">    <span class="comment">//检验商品合法性</span></span><br><span class="line">    Stock stock = stockDAO.checkStock(id);</span><br><span class="line">    <span class="keyword">if</span> (stock==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;商品不存在&quot;</span>);</span><br><span class="line">    log.info(<span class="string">&quot;商品信息&#123;&#125;:&quot;</span>,stock.toString());</span><br><span class="line">    <span class="comment">//生成haskey</span></span><br><span class="line">    String hashkey = <span class="string">&quot;KEY&quot;</span>+userid+id;</span><br><span class="line">    <span class="comment">//生成MD5</span></span><br><span class="line">    <span class="comment">//!Q*JS# 为盐 应该添加一个方法，随机生成六位随机字符</span></span><br><span class="line">    String key = DigestUtils.md5DigestAsHex((userid + id + <span class="string">&quot;!Q*JS#&quot;</span>).getBytes());</span><br><span class="line">    <span class="comment">//md5写入redis</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(hashkey, key,<span class="number">120</span>, TimeUnit.SECONDS);</span><br><span class="line">    log.info(<span class="string">&quot;redis写入&#123;&#125;&quot;</span>,hashkey,key);</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取MD5，进行比较</span></span><br><span class="line">String hashkey = <span class="string">&quot;KEY&quot;</span>+userid+id;</span><br><span class="line">String s =  stringRedisTemplate.opsForValue().get(hashkey);</span><br><span class="line"><span class="keyword">if</span> (s==<span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;redis中MD5为null&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!s.equals(md5))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;请求数据不合法，请从新尝试&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="用户调用接口限制"><a href="#用户调用接口限制" class="headerlink" title="用户调用接口限制"></a>用户调用接口限制</h3><p>防止单用户访问频率过多，根据用户id存入redis并设置过期时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">saveUserCount</span><span class="params">(Integer userid)</span> </span>&#123;</span><br><span class="line">    String Key = <span class="string">&quot;Key&quot;</span>+userid;</span><br><span class="line">    String limtNum = stringRedisTemplate.opsForValue().get(Key);</span><br><span class="line">    <span class="keyword">int</span> limit = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (limtNum==<span class="keyword">null</span>)&#123;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(Key, <span class="string">&quot;0&quot;</span>, <span class="number">3600</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        limit = Integer.parseInt(limtNum)+<span class="number">1</span>;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(Key, String.valueOf(limit), <span class="number">3600</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> limit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getUserCount</span><span class="params">(Integer userid)</span> </span>&#123;</span><br><span class="line">    String Key = <span class="string">&quot;Key&quot;</span>+ userid;</span><br><span class="line">    String limitNum = stringRedisTemplate.opsForValue().get(Key);</span><br><span class="line">    <span class="keyword">if</span>(limitNum==<span class="keyword">null</span>)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;用户没有申请核验记录，异常&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.parseInt(limitNum)&gt;<span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当用户调用接口限制</span></span><br><span class="line"><span class="keyword">int</span> i = userService.saveUserCount(id);</span><br><span class="line">log.info(<span class="string">&quot;用户访问秒杀次数&quot;</span>, i);</span><br><span class="line"><span class="comment">//判断用户点击是否超过限制</span></span><br><span class="line"><span class="keyword">boolean</span> check = userService.getUserCount(id);</span><br><span class="line"><span class="keyword">if</span> (check)&#123;</span><br><span class="line">    log.info(<span class="string">&quot;购买超过限制&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;购买超过频率限制&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>项目案例</category>
      </categories>
      <tags>
        <tag>秒杀</tag>
        <tag>项目案例</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式常用的七大原则</title>
    <url>/2020/06/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h2 id="设计模式常用的七大原则有"><a href="#设计模式常用的七大原则有" class="headerlink" title="设计模式常用的七大原则有"></a>设计模式常用的七大原则有</h2><p>设计原则核心思想</p>
<ol>
<li>找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代<br>码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>为了交互对象之间的松耦合设计而努力</li>
</ol>
<a id="more"></a>

<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p><strong>基本介绍</strong></p>
<ol>
<li> 对类来说的，即<strong>一个类应该只负责一项职责</strong>。如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责</li>
<li> 执行错误，所以需要将类A的粒度分解为 A1，A2</li>
</ol>
<p><strong>单一职责原则注意事项和细节</strong></p>
<ol>
<li>降低类的复杂度，一个类只负责一项职责（可以多个方法，但是职责统一）。</li>
<li>提高类的可读性，可维护性</li>
<li>降低变更引起的风险</li>
<li><strong><em>通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则(在一个类中有不同职责的方法)</em></strong></li>
</ol>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p><strong>基本介绍</strong></p>
<ol>
<li>客户端不应该依赖它不需要的接<br>口，即一个类对另一个类的依赖<br>应该<strong>建立在最小的接口上</strong></li>
</ol>
<p>类A通过接口Interface1依赖类B，类C通过接口Interface1依赖类D，如果接口Interface1对于类A和类C来说不是最小接口，那么类B和类D必须去实现他们不需要的方法。<br><img src="https://img-blog.csdnimg.cn/20200601125319631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjExMTMwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>按隔离原则应当这样处理：将接口Interface1拆分为独立的几个接口，类A和类C分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。<br>接口Interface1中出现的方法，根据实际情况拆分为三个接口<br><img src="https://img-blog.csdnimg.cn/20200601125354441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjExMTMwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="依赖倒转-倒置-原则"><a href="#依赖倒转-倒置-原则" class="headerlink" title="依赖倒转(倒置)原则"></a>依赖倒转(倒置)原则</h2><p><strong>依赖倒转原则(Dependence Inversion Principle)是指</strong>：</p>
<ol>
<li>高层模块不应该依赖低层模块，二者都应该依赖其抽象</li>
<li>抽象不应该依赖细节，细节应该依赖抽象</li>
<li>依赖倒转(倒置)的中心思想是<strong>面向接口编程</strong></li>
<li>依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，<strong>抽象指的是接口或抽象类，细节就是具体的实现类</strong></li>
<li><strong>使用接口或抽象类的目的是制定好规范</strong>，而不涉及任何具体的操作，把<strong>展现细节的任务交给他们的实现类去完成</strong></li>
</ol>
<p><strong>依赖倒转原则的注意事项和细节</strong></p>
<ol>
<li>低层模块尽量都要有<strong>抽象类或接口</strong>，或者两者都有，程序稳定性更好. </li>
<li>变量的声明类型尽量是抽象类或接口, 这样我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化</li>
<li>继承时遵循里氏替换原则</li>
</ol>
<p><strong>依赖关系传递的三种方式和应用案例</strong></p>
<ol>
<li>接口传递</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//方式1： 通过接口传递实现依赖</span></span><br><span class="line"> <span class="comment">//开关的接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span></span>; <span class="comment">//抽象方法,接收接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">//ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(ITV tv)</span> </span>&#123;</span><br><span class="line">        tv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">changhong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开电视&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>构造方法传递</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方式<span class="number">2</span>: 通过构造方法依赖传递</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">//抽象方法,接收接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">//ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITV itv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenAndClose</span><span class="params">(ITV itv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.itv = itv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.itv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">changhong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开电视&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>setter方式传递</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式3 , 通过setter方法传递</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>; <span class="comment">//抽象方法,接收接口</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITV</span> </span>&#123; <span class="comment">//ITV接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenAndClose</span> <span class="keyword">implements</span> <span class="title">IOpenAndClose</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ITV itv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItv</span><span class="params">(ITV itv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.itv = itv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.itv.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">changhong</span> <span class="keyword">implements</span> <span class="title">ITV</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开电视&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p><strong>OO中的继承性的思考和说明</strong></p>
<ol>
<li>继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是<strong>如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏</strong>。</li>
<li>继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，<strong>程序的可移植性降低，增加对象间的耦合性</strong>，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障</li>
<li>问题提出：在编程中，如何正确的使用继承? =&gt; 里氏替换原则</li>
</ol>
<p><strong>基本介绍</strong></p>
<ol>
<li>里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院的以为姓里的女士提出的。</li>
<li>如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。<strong>换句话说，所有引用基类的地方必须能透明地使用其子类的对象。</strong></li>
<li>在使用继承时，遵循里氏替换原则，在<strong>子类中尽量不要重写父类的方法</strong></li>
<li>里氏替换原则告诉我们，<strong>继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖 来解决问题</strong></li>
</ol>
<p><strong>解决方法</strong></p>
<p> 通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，<strong>采用依赖，聚合，组合等关系代替</strong></p>
<p><strong>未使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回两个数的差</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 - num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用里氏替换原则（组合）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建一个更加基础的基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">//把更加基础的方法和成员写到Base类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回两个数的差</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num1 - num2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B类继承了A</span></span><br><span class="line"><span class="comment">// 增加了一个新功能：完成两个数相加,然后和9求和</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果B需要使用A类的方法,使用组合关系</span></span><br><span class="line">	<span class="keyword">private</span> A a = <span class="keyword">new</span> A();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//这里，重写了A类的方法, 可能是无意识</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> func1(a, b) + <span class="number">9</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//我们仍然想使用A的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.a.func1(a, b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><strong>基本介绍</strong></p>
<ol>
<li>开闭原则（Open Closed Principle）是编程中最基础、最重要的设计原则</li>
<li>一个软件实体如类，模块和函数应该<strong>对扩展开放(对提供方)**，</strong>对修改关闭(对使用方)**。用抽象构建框架，用实现扩展细节。</li>
<li>当软件需要变化时，尽量<strong>通过扩展软件实体的行为来实现变化</strong>，而<strong>不是通过修改已有的代码来实现变化</strong>。</li>
<li>编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s.m_type == <span class="number">1</span>)</span><br><span class="line">drawRectangle(s);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s.m_type == <span class="number">2</span>)</span><br><span class="line">drawCircle(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;矩形&quot;</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">(Shape r)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;圆形&quot;</span>);</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">Rectangle() &#123;</span><br><span class="line"><span class="keyword">super</span>.m_type = <span class="number">1</span>;</span><br><span class="line">&#125;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">Circle() &#123;</span><br><span class="line"><span class="keyword">super</span>.m_type = <span class="number">2</span>;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>扩展程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个用于绘图的类 [使用方]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphicEditor</span> </span>&#123;</span><br><span class="line">	<span class="comment">//接收Shape对象，调用draw方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawShape</span><span class="params">(Shape s)</span> </span>&#123;</span><br><span class="line">		s.draw();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Shape类，基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制矩形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制圆形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增画三角形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制三角形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//新增一个图形</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OtherGraphic</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot; 绘制其它图形 &quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>基本介绍</p>
<ol>
<li>一个对象应该对其他<strong>对象保持最少的了解</strong></li>
<li>类与类关系越密切，耦合度越大</li>
<li>迪米特法则(Demeter Principle)又叫<strong>最少知道原则</strong>，即一个类对自己依赖的类知道的越少越好。也就是说，对于<strong>被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部</strong>。<strong>对外除了提供的public 方法，不对外泄露任何信息</strong></li>
<li>迪米特法则还有个更简单的定义：<strong>只与直接的朋友通信</strong></li>
<li>直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，<strong>我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友</strong>，而出现在<strong>局部变量中的类不是直接的朋友</strong>。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部</li>
</ol>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p><strong>基本介绍</strong></p>
<ol>
<li>原则是尽量使用<strong>合成/聚合</strong>的方式，而不是使用继承<br><img src="https://img-blog.csdnimg.cn/20200601233005896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjExMTMwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>七大原则</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2021/02/23/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>贪心的意思在于在作出选择时，每次都要选择对自身最为有利的结果，保证自身利益的最大化。贪心算法就是利用这种贪心思想而得出一种算法。</p>
<p>贪心算法可以简单描述为：大事化小，小事化了。对于一个较大的问题，通过找到与子问题的重叠，把复杂的问题划分为多个小问题。并且对于每个子问题的解进行选择，找出最优值，进行处理，再找出最优值，再处理。也就是说贪心算法是一种在每一步选择中都采取在当前状态下最好或最优的选择，从而希望得到结果是最好或最优的算法。</p>
<a id="more"></a>

<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>（1）建立数学模型来描述问题。<br>（2）把求解的问题分成若干个子问题。<br>（3）对每一子问题求解，得到子问题的局部最优解。<br>（4）把子问题的局部最优解合成原来问题的一个解。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>基本算法思想</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程</title>
    <url>/2021/02/26/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="进程和线程的概念"><a href="#进程和线程的概念" class="headerlink" title="进程和线程的概念"></a>进程和线程的概念</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的</li>
</ul>
<a id="more"></a>

<ul>
<li><p>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</p>
</li>
<li><p>进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</p>
</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><ul>
<li><p>一个进程之内可以分为一到多个线程。</p>
</li>
<li><p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行</p>
</li>
<li><p>Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器</p>
</li>
</ul>
<h3 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h3><ul>
<li><p>进程基本上相互独立的，而线程存在于进程内，是进程的一个子集</p>
</li>
<li><p>进程拥有共享的资源，如内存空间等，供其内部的线程共享</p>
</li>
<li><p>进程间通信较为复杂</p>
<p>​    同一台计算机的进程通信称为 IPC（Inter-process communication）</p>
<p>​    不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</p>
</li>
<li><p>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</p>
</li>
<li><p>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</p>
</li>
</ul>
<h2 id="并行和并发的概念"><a href="#并行和并发的概念" class="headerlink" title="并行和并发的概念"></a>并行和并发的概念</h2><p>单核 cpu 下，线程实际还是 串行执行 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是 同时运行的 。总结为一句话就是： 微观串行，宏观并行 </p>
<p>一般会将这种 线程轮流使用 CPU 的做法称为<strong>并发</strong>， concurrent</p>
<p>多核 cpu下，每个 核（core） 都可以调度运行线程，这时候线程可以是<strong>并行</strong>的</p>
<ul>
<li>并发（concurrent）是同一时间应对（dealing with）多件事情的能力</li>
<li>并行（parallel）是同一时间动手做（doing）多件事情的能力</li>
</ul>
<h2 id="线程基本应用"><a href="#线程基本应用" class="headerlink" title="线程基本应用"></a>线程基本应用</h2>]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2021/03/04/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>适配器模式(Adapter Pattern) ：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
<a id="more"></a>

<h3 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h3><p>适配器模式包含如下角色：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Target：目标抽象类</span><br><span class="line">Adapter：适配器类</span><br><span class="line">Adaptee：适配者类</span><br><span class="line">Client：客户类</span><br><span class="line">1234</span><br></pre></td></tr></table></figure>
<p><strong>类适配器：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Target：目标抽象类</span><br><span class="line"><span class="comment">//接口转换器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetToUsb</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理请求，连接网线</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br><span class="line">Adapter：适配器类</span><br><span class="line"><span class="comment">//适配器 连接网线，连接usb</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">NetToUsb</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br><span class="line"> Adaptee：适配者类</span><br><span class="line"><span class="comment">//要被适配得的类  网线</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接网线上网&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br><span class="line"> Client：客户类</span><br><span class="line"><span class="comment">//电脑上网：插不上网线</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//连接转接头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">net1</span><span class="params">(Adapter adapter)</span></span>&#123;</span><br><span class="line">        adapter.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200604124920105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjExMTMwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>对象适配器：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口转换器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetToUsb</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理请求，连接网线</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapterpro</span> <span class="keyword">implements</span> <span class="title">NetToUsb</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdaptee</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br><span class="line"><span class="comment">//要被适配得的类  网线</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接网线上网&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br><span class="line"><span class="comment">//电脑上网：插不上网线</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//连接转接头</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">net1</span><span class="params">(Adapter adapter)</span></span>&#123;</span><br><span class="line">        adapter.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">net</span><span class="params">(Adapterpro adapterpro)</span></span>&#123;</span><br><span class="line">        adapterpro.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200604125148772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjExMTMwMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。</li>
<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li>
</ol>
<p><strong>类适配器模式还具有如下优点</strong><br>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。<br><strong>对象适配器模式还具有如下优点</strong><br>一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>类适配器模式的缺点如下：<br>对于<strong>Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类</strong>，而且目标抽象类只能为抽象类，不能为具体类，其使用有一定的局限性，不能将一个适配者类和它的子类都适配到目标接口。</li>
<li>对象适配器模式的缺点如下：<br>与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li>
</ol>
<h3 id="与其他模式的关系"><a href="#与其他模式的关系" class="headerlink" title="与其他模式的关系"></a>与其他模式的关系</h3><ul>
<li>桥接模式通常会于开发前期进行设计， 使你能够将程序的各个部分独立开来以便开发。 另一方面， 适配器模式通常在已有程序中使用， 让相互不兼容的类能很好地合作。</li>
<li>适配器可以对已有对象的接口进行修改， 装饰模式则能在不改变对象接口的前提下强化对象功能。 此外， <em>装饰</em>还支持递归组合， <em>适配器</em>则无法实现。</li>
<li>适配器能为被封装对象提供不同的接口， 代理模式能为对象提供相同的接口， 装饰则能为对象提供加强的接口。</li>
<li>外观模式为现有对象定义了一个新接口， 适配器则会试图运用已有的接口。 <em>适配器</em>通常只封装一个对象， <em>外观</em>通常会作用于整个对象子系统上。</li>
<li>桥接、 状态模式和策略模式（在某种程度上包括适配器） 模式的接口非常相似。 实际上， 它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-结构型模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring常见问题</title>
    <url>/2020/09/19/Spring%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="什么是 Spring 框架?"></a>什么是 Spring 框架?</h2><p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。Spring 官网：<a href="https://spring.io/">https://spring.io/</a></p>
<p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<a id="more"></a>

<h2 id="RestController-vs-Controller"><a href="#RestController-vs-Controller" class="headerlink" title="@RestController vs @Controller"></a>@RestController vs @Controller</h2><p><code>@ResponseBody</code> 注解的作用是将 <code>Controller</code> 的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到HTTP 响应(Response)对象的 body 中，通常用来返回 JSON 或者 XML 数据，返回 JSON 数据的情况比较多。</p>
<ul>
<li><strong><code>@RestController</code> 返回JSON 或 XML 形式数据</strong></li>
</ul>
<p>但<code>@RestController</code>只返回对象，对象数据直接以 JSON 或 XML 形式写入 HTTP 响应(Response)中，这种情况属于 RESTful Web服务，这也是目前日常开发所接触的最常用的情况（前后端分离）。</p>
<ul>
<li><strong><code>@Controller +@ResponseBody</code> 返回JSON 或 XML 形式数据</strong></li>
</ul>
<p>如果你需要在Spring4之前开发 RESTful Web服务的话，你需要使用<code>@Controller</code> 并结合<code>@ResponseBody</code>注解，也就是说<code>@Controller</code> +<code>@ResponseBody</code>= <code>@RestController</code>（Spring 4 之后新加的注解）。</p>
<h2 id="Spring-IOC-amp-AOP"><a href="#Spring-IOC-amp-AOP" class="headerlink" title="Spring IOC &amp; AOP"></a>Spring IOC &amp; AOP</h2><ol>
<li> IoC</li>
</ol>
<p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 <strong>IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong></p>
<p>IoC的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度。</p>
<p>要理解<strong>控制反转</strong>首先清楚<strong>依赖倒置原则（Dependency Inversion Principle ）</strong>。</p>
<p>推荐阅读</p>
<ul>
<li>举例理解：<a href="https://www.zhihu.com/question/23277575/answer/169698662">https://www.zhihu.com/question/23277575/answer/169698662</a></li>
<li>IoC源码阅读：<a href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></li>
<li>如何完美的向面试官阐述你对IOC的理解？：<a href="https://www.zhihu.com/question/313785621/answer/610907694">https://www.zhihu.com/question/313785621/answer/610907694</a></li>
</ul>
<ol start="2">
<li>AOP</li>
</ol>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<h2 id="Spring-bean"><a href="#Spring-bean" class="headerlink" title="Spring bean"></a>Spring bean</h2><h3 id="4-1-Spring-中的-bean-的作用域有哪些"><a href="#4-1-Spring-中的-bean-的作用域有哪些" class="headerlink" title="4.1 Spring 中的 bean 的作用域有哪些?"></a>4.1 Spring 中的 bean 的作用域有哪些?</h3><ul>
<li><p>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</p>
</li>
<li><p>prototype : 每次请求都会创建一个新的 bean 实例。</p>
</li>
<li><p>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</p>
</li>
<li><p>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</p>
</li>
<li><p>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</p>
</li>
</ul>
<h3 id="4-2-Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#4-2-Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="4.2 Spring 中的单例 bean 的线程安全问题了解吗？"></a>4.2 Spring 中的单例 bean 的线程安全问题了解吗？</h3><p>的确是存在安全问题的。因为，当多个线程操作同一个对象的时候，对这个对象的成员变量的写操作会存在线程安全问题。</p>
<p>但是，一般情况下，我们常用的 <code>Controller</code>、<code>Service</code>、<code>Dao</code> 这些 Bean 是无状态的。无状态的 Bean 不能保存数据，因此是线程安全的。</p>
<p>常见的有 2 种解决办法：</p>
<ol>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
<li>改变 Bean 的作用域为 “prototype”：每次请求都会创建一个新的 bean 实例，自然不会存在线程安全问题。</li>
</ol>
<h3 id="4-3-Component-和-Bean-的区别是什么？"><a href="#4-3-Component-和-Bean-的区别是什么？" class="headerlink" title="4.3 @Component 和 @Bean 的区别是什么？"></a>4.3 @Component 和 @Bean 的区别是什么？</h3><ol>
<li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ol>
<p><code>@Bean</code>注解使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>上面的代码相当于下面的 xml 配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transferService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.acme.TransferServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;<span class="name">Copy</span></span> to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OneService <span class="title">getService</span><span class="params">(status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl1();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl2();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<h3 id="4-4-将一个类声明为Spring的-bean-的注解有哪些"><a href="#4-4-将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="4.4 将一个类声明为Spring的 bean 的注解有哪些?"></a>4.4 将一个类声明为Spring的 bean 的注解有哪些?</h3><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h3 id="4-5-Spring-中的-bean-生命周期"><a href="#4-5-Spring-中的-bean-生命周期" class="headerlink" title="4.5 Spring 中的 bean 生命周期?"></a>4.5 Spring 中的 bean 生命周期?</h3><p>这部分网上有很多文章都讲到了，下面的内容整理自：<a href="https://yemengying.com/2016/07/14/spring-bean-life-cycle/">https://yemengying.com/2016/07/14/spring-bean-life-cycle/</a> ，除了这篇文章，再推荐一篇很不错的文章 ：<a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a> 。</p>
<ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<p>图示：</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/48376272.jpg" alt="Spring Bean 生命周期"></p>
<p>与之比较类似的中文版本:</p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/5496407.jpg" alt="Spring Bean 生命周期"></p>
<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="5-1-说说自己对于-Spring-MVC-了解"><a href="#5-1-说说自己对于-Spring-MVC-了解" class="headerlink" title="5.1 说说自己对于 Spring MVC 了解?"></a>5.1 说说自己对于 Spring MVC 了解?</h3><p>谈到这个问题，我们不得不提提之前 Model1 和 Model2 这两个没有 Spring MVC 的时代。</p>
<ul>
<li><strong>Model1 时代</strong> : 很多学 Java 后端比较晚的朋友可能并没有接触过 Model1 模式下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。这个模式下 JSP 既是控制层又是表现层。显而易见，这种模式存在很多问题。比如①将控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；②前端和后端相互依赖，难以进行测试并且开发效率极低；</li>
<li><strong>Model2 时代</strong> ：学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View,）+Servlet（Controller） ”这种开发模式,这就是早期的 JavaWeb MVC 开发模式。Model:系统涉及的数据，也就是 dao 和 bean。View：展示模型中的数据，只是用来展示。Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。</li>
</ul>
<p>Model2 模式下还存在很多问题，Model2的抽象和封装程度还远远不够，使用Model2进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。于是很多JavaWeb开发相关的 MVC 框架应运而生比如Struts2，但是 Struts2 比较笨重。随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p>
<p>MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。</p>
<p><strong>Spring MVC 的简单原理图如下：</strong></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/60679444.jpg" alt="img"></p>
<h3 id="5-2-SpringMVC-工作原理了解吗"><a href="#5-2-SpringMVC-工作原理了解吗" class="headerlink" title="5.2 SpringMVC 工作原理了解吗?"></a>5.2 SpringMVC 工作原理了解吗?</h3><p><strong>原理如下图所示：</strong> <img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-10-11/49790288.jpg" alt="SpringMVC运行原理"></p>
<p>上图的一个笔误的小问题：Spring MVC 的入口函数也就是前端控制器 <code>DispatcherServlet</code> 的作用是接收请求，响应结果。</p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</li>
<li>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler </code>来调用真正的处理器来处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h2 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h2><p>关于下面一些设计模式的详细介绍，可以看笔主前段时间的原创文章<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485303&idx=1&sn=9e4626a1e3f001f9b0d84a6fa0cff04a&chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&token=255050878&lang=zh_CN#rd">《面试官:“谈谈Spring中都用到了那些设计模式?”。》</a> 。</p>
<ul>
<li><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>……</li>
</ul>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><h3 id="7-1-Spring-管理事务的方式有几种？"><a href="#7-1-Spring-管理事务的方式有几种？" class="headerlink" title="7.1 Spring 管理事务的方式有几种？"></a>7.1 Spring 管理事务的方式有几种？</h3><ol>
<li>编程式事务，在代码中硬编码。(不推荐使用)</li>
<li>声明式事务，在配置文件中配置（推荐使用）</li>
</ol>
<p><strong>声明式事务又分为两种：</strong></p>
<ol>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ol>
<h3 id="7-2-Spring-事务中的隔离级别有哪几种"><a href="#7-2-Spring-事务中的隔离级别有哪几种" class="headerlink" title="7.2 Spring 事务中的隔离级别有哪几种?"></a>7.2 Spring 事务中的隔离级别有哪几种?</h3><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong> 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="7-3-Spring-事务中哪几种事务传播行为"><a href="#7-3-Spring-事务中哪几种事务传播行为" class="headerlink" title="7.3 Spring 事务中哪几种事务传播行为?"></a>7.3 Spring 事务中哪几种事务传播行为?</h3><p><strong>支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h3 id="7-4-Transactional-rollbackFor-Exception-class-注解了解吗？"><a href="#7-4-Transactional-rollbackFor-Exception-class-注解了解吗？" class="headerlink" title="7.4 @Transactional(rollbackFor = Exception.class)注解了解吗？"></a>7.4 @Transactional(rollbackFor = Exception.class)注解了解吗？</h3><p>我们知道：Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当<code>@Transactional</code>注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在<code>@Transactional</code>注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚,加上<code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
<p>关于 <code>@Transactional </code> 注解推荐阅读的文章：</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-master-spring-transactional-use/index.html">透彻的掌握 Spring 中@transactional 的使用</a></li>
</ul>
<h2 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h2><h3 id="8-1-如何使用JPA在数据库中非持久化一个字段？"><a href="#8-1-如何使用JPA在数据库中非持久化一个字段？" class="headerlink" title="8.1 如何使用JPA在数据库中非持久化一个字段？"></a>8.1 如何使用JPA在数据库中非持久化一个字段？</h3><p>假如我们有有下面一个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Entity(name=<span class="string">&quot;USER&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;ID&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name=&quot;USER_NAME&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column(name=&quot;PASSWORD&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> String secrect;</span><br><span class="line">  </span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>
<p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String transient1; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> String transient2 = “Satish”; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String transient3; <span class="comment">// not persistent because of transient</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line">String transient4; <span class="comment">// not persistent because of @TransientCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>
<p>一般使用后面两种方式比较多，我个人使用注解的方式比较多。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
</search>
